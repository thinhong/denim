[{"path":[]},{"path":"/articles/deSolve_to_denim.html","id":"original-code-in-desolve","dir":"Articles","previous_headings":"Migrate deSolve code to denim","what":"Original code in deSolve","title":"deSolve to denim","text":"model used demonstrating process migrating code deSolve denim followed","code":"# --- Model definition in deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {       dS = -beta*S*I/N       dI1 = beta*S*I/N - rate*I1       dI2 = rate*I1 - rate*I2       dI =  dI1 + dI2       dR = rate*I2       list(c(dS, dI, dI1, dI2, dR))   }) }  # ---- Model configuration  parameters <- c(beta = 0.3, rate = 1/3, N = 1000)  initialValues <- c(S = 999, I = 1, I1 = 1, I2=0, R=0)  # ---- Run simulation times <- seq(0, 100) # simulation duration ode_mod <- ode(y = initialValues, times = times, parms = parameters, func = transition_func)  # --- show output ode_mod <- as.data.frame(ode_mod) head(ode_mod[-1, c(\"time\", \"S\", \"I\", \"R\")]) ##   time        S        I          R ## 2    1 998.6561 1.294182 0.04969647 ## 3    2 998.2239 1.594547 0.18152864 ## 4    3 997.6985 1.921416 0.38010527 ## 5    4 997.0695 2.290735 0.63971843 ## 6    5 996.3225 2.716551 0.96093694 ## 7    6 995.4387 3.212577 1.34869352"},{"path":"/articles/deSolve_to_denim.html","id":"model-definition","dir":"Articles","previous_headings":"Migrate deSolve code to denim","what":"Model definition","title":"deSolve to denim","text":"Unlike deSolve transitions compartments defined system ODEs, transitions denim must defined () distribution dwell-time (either parametric non-parametric) (ii) mathematical expression. User must first identify transitions best describe ones deSolve model. transitions identified, user can define model denim. using denim DSL, model structure given set key-value pairs key shows transition direction compartments format compartment -> out_compartment value built-distribution function describe transition","code":"# --- Model definition in deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {              # For S -> I transition, since it involves parameters (beta, N),        # the best transition to describe this is using a mathematical formula       dS = -beta*S*I/N              # For I -> R transition, linear chain trick is applied --> implies Erlang distributed dwell time       # Hence, we can use d_gamma from denim       dI1 = beta*S*I/N - rate*I1       dI2 = rate*I1 - rate*I2       dI =  dI1 + dI2       dR = rate*I2       list(c(dS, dI, dI1, dI2, dR))   }) } # --- Model definition in denim transitions <- denim_dsl({   S -> I = beta * S * I/N   # shape is 2 from number of I sub compartments   I -> R = d_gamma(rate = 1/3, shape = 2)  })"},{"path":"/articles/deSolve_to_denim.html","id":"model-configurations","dir":"Articles","previous_headings":"Migrate deSolve code to denim","what":"Model configurations","title":"deSolve to denim","text":"Similar deSolve, denim also ask users provide initial values additional parameters form named vectors. example deSolve code, users can use initalValues deSolve code (denim ignore unused I1, I2 compartments sub-compartments automatically computed internally), recommended remove redundant compartments (example, I1 I2). parameters, since rate already defined distribution functions, users need keep beta N initial parameters vector. need specify value timeStep variable special variable denim defined later . Initialization sub-compartments: multiple sub-compartments (e.g., compartment consist I1 I2 sub-compartments), initial population always assigned first sub-compartment. example, since = 1, denim assign I1 = 1 I2 = 0. also option distribute initial value across sub-compartments based specified distribution. , simply set dist_init parameter distribution function TRUE. However, comparison purposes, keep option FALSE remaining demonstration.","code":"# remove I1, I2 compartments denim_initialValues <- c(S = 999, I = 1, R=0) denim_parameters <- c(beta = 0.3, N = 1000) transitions <- denim_dsl({   S -> I = beta * S * I/N    I -> R = d_gamma(rate = 1/3, shape = 2, dist_init = TRUE)  })"},{"path":"/articles/deSolve_to_denim.html","id":"simulation","dir":"Articles","previous_headings":"Migrate deSolve code to denim","what":"Simulation","title":"deSolve to denim","text":"Lastly, users need define simulation duration time step denim run. Unlike deSolve takes time sequence, denim require simulation duration time step. Since denim discrete time model, time step must set small value result closely follow deSolve (example, 0.01).","code":"mod <- sim(transitions = transitions,              initialValues = denim_initialValues,               parameters = denim_parameters,              simulationDuration = 100,              timeStep = 0.01)  head(mod[mod$Time %% 1 == 0, ]) ##     Time        S        I          R ## 1      0 999.0000 1.000000 0.00000000 ## 101    1 998.6566 1.293759 0.04961535 ## 201    2 998.2251 1.593725 0.18121212 ## 301    3 997.7004 1.920189 0.37940195 ## 401    4 997.0725 2.289061 0.63848007 ## 501    5 996.3266 2.714365 0.95900520"},{"path":"/articles/deSolve_to_denim.html","id":"compare-output","dir":"Articles","previous_headings":"","what":"Compare output","title":"deSolve to denim","text":"following plots show output denim deSolve","code":""},{"path":"/articles/denim.html","id":"simple-sir-model-with-gamma-distributed-lengths-of-stay","dir":"Articles","previous_headings":"","what":"1. Simple SIR model with gamma distributed lengths of stay","title":"denim: deterministic discrete-time model with memory","text":"SIR model uses 3 compartments: S (susceptible), (infected), R (recovered) describe clinical status individuals. use simple form SIR model demonstrate define distribution lengths stay distribution. model equations : \\[S_{t+1} - S_{t} = -\\lambda S_{t} = -\\frac{\\beta I_{t}}{N}S_{t}\\] \\[I_{t+1} - I_{t} = \\frac{\\beta I_{t}}{N}S_{t} - \\gamma I_{t}\\] \\[R_{t+1} - R_{t} = \\gamma I_{t}\\] \\(N\\): total population size, \\(N = S + + R\\) \\(\\beta\\): product contact rates transmission probability; usually define \\(\\lambda =\\frac{\\beta I_{t}}{N}\\) force infection \\(\\gamma\\): recovery rate Usually solve model easier make assumption recovery rate \\(\\gamma\\) constant, leads exponentially distributed length stay .e individuals recover 1 day infected.  realistic length stay distribution can look like , patients recovered 4 days. defined using gamma distribution shape = 3 rate = 1/2.  model now look like : Model specification Model transition two transitions S -> -> R case. transitions specified list follow format \"transition\" = equation\", equation defined one functions waiting time distribution. Another option define transitions using denim’s DSL. Refer Model definition denim article information. Initial state Use vector define compartments assigned names initial values format compartment_name = initial_value: Model parameters use math expression, symbols except compartment names parameters, defined constant values. two constant parameters example: beta N: Model application Time step specification run model 30 days give output 0.01 daily intervals. default interval (time step) 1 declared explicitly.","code":"transitions <- list(   \"S -> I\" = \"beta * S * I / N\",   \"I -> R\" = d_gamma(rate = 1/2, 3) ) transitions <- denim_dsl({   S -> I = beta * (I/N) * S   I -> R = d_gamma(rate = 1/4, shape = 3) }) initialValues <- c(   S = 999,    I = 1,    R = 0 ) parameters <- c(   beta = 1.2,   N = 1000 ) simulationDuration <- 30 timeStep <- 0.01 mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) head(mod) #>   Time        S        I            R #> 1 0.00 999.0000 1.000000 0.000000e+00 #> 2 0.01 998.9880 1.011988 2.599289e-09 #> 3 0.02 998.9759 1.024120 2.078652e-08 #> 4 0.03 998.9636 1.036396 7.019852e-08 #> 5 0.04 998.9512 1.048820 1.665435e-07 #> 6 0.05 998.9386 1.061393 3.256027e-07 plot(mod)"},{"path":"/articles/denim.html","id":"how-the-algorithm-work","dir":"Articles","previous_headings":"","what":"2. How the algorithm work?","title":"denim: deterministic discrete-time model with memory","text":"SIR model, infected individuals presented single compartment recovery rate \\(\\gamma\\). want recovery rate individuals infected 1 day differ recovery rate 2-day infected patients. rather using one compartment infected (), define multiple infected sub-compartments. number sub-compartments depends maximum day expect infected individuals recovered. example, expect disease maximum 4 days infection, end 4 sub-compartments. sub-compartment recovery rate \\(\\gamma_{1}\\), \\(\\gamma_{2}\\), \\(\\gamma_{3}\\), \\(\\gamma_{4}\\). day 4 certain patient recover (assume disease maximum 4 days infection), \\(\\gamma_{4} = 1\\). Let \\(R_1 + R_2 + R_3 + R_4 = \\Sigma R\\). \\(\\frac{R_1}{\\Sigma R} = p_1\\), \\(\\frac{R_2}{\\Sigma R} = p_2\\), \\(\\frac{R_3}{\\Sigma R} = p_3\\), \\(\\frac{R_4}{\\Sigma R} = p_4\\). mission estimate \\(\\gamma_{1}\\), \\(\\gamma_{2}\\), \\(\\gamma_{3}\\) obtain \\(p_1\\), \\(p_2\\), \\(p_3\\), \\(p_4\\) fit pre-defined distribution equilibrium state. can obtained setting: \\[\\gamma_{} = \\frac{p_i}{1 - \\sum_{j=1}^{-1}p_j}\\] given length stay distribution, identify maximum length stay using cumulative distribution function. cumulative distribution function asymptotic 1 never equal 1, need set value acceptable rounded 1. want cumulative probability 0.999 rounded 1, set error tolerance threshold 1 - 0.999 = 0.001 (specified argument errorTolerance = 0.001). time cumulative probability = 0.999 set maximum length stay compartment. Default errorTolerance denim set 0.001. Initialize population sub-compartments default, initial population always assigned first sub-compartment (example, initial value compartment = 1, denim initialize I1 = 1 I2 = I3 = I4 = 0). User can also choose distribute initial population across sub-compartments based specified distribution, .e. initial population = n, denim initialize I1 = n*p1, I2 = n*p2, I3 = n*p3, I4 = n*p4. set initial population way, simply specify parameter dist_init = TRUE (applicable distribution transitions).","code":"transitions <- denim_dsl({   S -> I = beta * S * I / N    I -> R = d_gamma(rate = 1/2, 3, dist_init=TRUE) })"},{"path":"/articles/denim.html","id":"waiting-time-distribution","dir":"Articles","previous_headings":"","what":"3. Waiting time distribution","title":"denim: deterministic discrete-time model with memory","text":"denim offers 2 main ways define transition: either waiting time distribution, mathematical expression. Current available distributions package including: d_exponential(rate): Discrete exponential distribution parameter rate d_gamma(rate, shape): Discrete gamma distribution parameters rate shape d_weibull(scale, shape): Discrete Weibull distribution parameters scale shape d_lognormal(mu, sigma): Discrete log-normal distribution parameters mu sigma nonparametric(waitingTimes): vector values, numbers, percentages, density length stay based real data, denim convert distribution Mathematical expression: Transition can also described using math expression beta * S * / N. need define parameters compartment names parameters argument","code":""},{"path":"/articles/denim.html","id":"multiple-transitions-from-a-compartment","dir":"Articles","previous_headings":"","what":"4. Multiple transitions from a compartment","title":"denim: deterministic discrete-time model with memory","text":"denim, transitions one compartment multiple compartments modeled either () multinomial transition (ii) competing risks. Consider example: two scenarios example: Susceptible individuals can infected vaccinated. assumption infected first (S -> ), rest infected get vaccinated (S -> V). Infected individuals can recover die. mortality probability known, can implement model, example defining 0.9 * -> R (90% individuals recover) 0.1 * -> D (10% die). , ensure mortality probability 10%, also define length stay individuals infected state recover die follows gamma log-normal distribution, respectively. can define model example follows:  detailed explanation transitions multiple states, refer article","code":"transitions <- denim_dsl({   S -> I = beta * S * I / N    S -> V = 5   0.9 * I -> R = d_gamma(1/3, 2)   0.1 * I -> D = d_lognormal(2, 0.5) })  initialValues <- c(   S = 999,    I = 1,    R = 0,   V = 0,   D = 0 )  parameters <- c(   beta = 1.2,   N = 1000 )  simulationDuration <- 20 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep)  head(mod) #>   Time        S        I    V            R            D #> 1 0.00 999.0000 1.000000 0.00 0.000000e+00 0.000000e+00 #> 2 0.01 998.9380 1.011983 0.05 4.988903e-06 0.000000e+00 #> 3 0.02 998.8759 1.024099 0.10 1.997114e-05 1.466074e-33 #> 4 0.03 998.8136 1.036349 0.15 4.500034e-05 1.651885e-29 #> 5 0.04 998.7512 1.048736 0.20 8.013109e-05 8.335817e-27 #> 6 0.05 998.6886 1.061259 0.25 1.254190e-04 8.306459e-25 plot(mod, ylim = c(0, 1000))"},{"path":"/articles/denim.html","id":"another-example","dir":"Articles","previous_headings":"","what":"5. Another example","title":"denim: deterministic discrete-time model with memory","text":"","code":"transitions <- denim_dsl({   S -> I = beta * S * (I + IV) / N    S -> V = 2   0.1 * I -> D = d_lognormal(mu = d_mu, sigma = d_sigma)   0.9 * I -> R = d_gamma(rate = r_rate, shape = r_shape)   V -> IV = 0.1 * beta * V * (I + IV) / N   IV -> R = d_exponential(iv_r_rate) })  initialValues <- c(   S = 999,    I = 1,    R = 0,   V = 0,   IV = 0,   D = 0 )  parameters <- c(   beta = 1.2,   N = 1000,   d_mu = 2,   d_sigma = 1/2,   r_rate = 1/3,   r_shape = 2,   iv_r_rate = 2 )  simulationDuration <- 20 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) plot(mod) head(mod) #>   Time        S        I          V           IV            D            R #> 1 0.00 999.0000 1.000000 0.00000000 0.000000e+00 0.000000e+00 0.000000e+00 #> 2 0.01 998.9680 1.011983 0.02000000 0.000000e+00 0.000000e+00 4.988903e-06 #> 3 0.02 998.9359 1.024099 0.03999998 2.428759e-08 1.466074e-33 1.997114e-05 #> 4 0.03 998.9036 1.036350 0.05999993 7.296340e-08 1.651885e-29 4.500082e-05 #> 5 0.04 998.8712 1.048738 0.07999985 1.461358e-07 8.335817e-27 8.013303e-05 #> 6 0.05 998.8386 1.061263 0.09999975 2.439207e-07 8.306459e-25 1.254238e-04"},{"path":"/articles/denim_benchmark.html","id":"benchmark-settings","dir":"Articles","previous_headings":"","what":"Benchmark settings","title":"denim benchmark","text":"approaches simulate following SEIR model, simulation duration 180 beta can also computed \\(beta = R_0/tr\\) \\(R_0\\) basic reproduction number \\(tr\\) infectious period. approach run 50 times","code":"total_runs <- 50L # number of runs sim_duration <- 180 # duration of simulation"},{"path":"/articles/denim_benchmark.html","id":"useir","dir":"Articles","previous_headings":"","what":"1. uSEIR","title":"denim benchmark","text":"Simulate model using uSEIR approach (Hernández et al. 2021). Source code: https://github.com/jjgomezcadenas/useirn/blob/master/nb/uSEIR.ipynb","code":"library(reticulate) ## Warning: package 'reticulate' was built under R version 4.3.3 # use_python(\"/opt/anaconda3/envs/bnn/bin/python\", required = TRUE) use_condaenv(condaenv='bnn', required = TRUE) matplotlib <- import(\"matplotlib\") matplotlib$use(\"Agg\", force = TRUE) py_run_file(\"../supplements/useir_python.py\")"},{"path":"/articles/denim_benchmark.html","id":"python-implementation","dir":"Articles","previous_headings":"1. uSEIR","what":"1.1. Python implementation","title":"denim benchmark","text":"Run time uSEIR approach, Python implementation (seconds) Median run time uSEIR approach, Python implementation: 53.7090955 seconds","code":"import time import concurrent.futures import pickle import os from statistics import mean  python_runs = []  def get_python_runtime(n):   start = time.time()   df = solve_uSeir(ti_shape     = 2,                      ti_scale     = 4,                      tr_shape     = 2,                      tr_scale     = 3,                      R0           = 3.5)   end = time.time()   return end - start    # load cached result if available instead of rerun due to long run time cached_python_runs = \"../supplements/cached_runs/python_runs.pkl\" if os.path.exists(cached_python_runs):   # If the file exists, load the Python list from the file   with open(cached_python_runs, 'rb') as f:     python_runs = pickle.load(f) else:   print(\"no cache found\")   # multithread instead for quicker result   with concurrent.futures.ProcessPoolExecutor(max_workers=8) as executor:     python_runs = list(executor.map(get_python_runtime, range(r.total_runs)))   # Save to cache   with open(cached_python_runs, 'wb') as f:       pickle.dump(python_runs, f)        # plot_useir((df,), ('G',), T = 'uSEIR', figsize=(14,8)) # print(f'python solve_seir call: dr = {end-start}') ##  [1] 54.79370 54.23037 54.61863 54.13476 54.73439 54.35928 54.48391 54.56821 ##  [9] 53.26567 53.35437 53.44551 53.31425 53.51092 53.19878 53.92493 53.84889 ## [17] 54.05378 53.66922 53.65536 53.54520 53.73345 53.88690 54.23988 54.19460 ## [25] 53.64543 53.55217 53.66061 53.67430 53.59397 53.65503 54.32232 53.98363 ## [33] 53.53084 53.79021 53.85689 53.45313 53.61043 53.53294 54.00833 54.11180 ## [41] 53.94760 53.61952 53.80676 53.74364 53.68474 53.63701 53.59615 53.81793 ## [49] 44.74661 44.77127"},{"path":"/articles/denim_benchmark.html","id":"cython-implementation","dir":"Articles","previous_headings":"1. uSEIR","what":"1.2. Cython implementation","title":"denim benchmark","text":"Run time uSEIR approach, Cython implementation (seconds) Median run time uSEIR approach, Cython implementation: 0.4189816 seconds","code":"# import precompiled cython module import sys sys.path.insert(0, \"../supplements\") import useir import time import pyarrow as pa  cython_runs = []  # --- Get runtime ---- for i in range(r.total_runs):   start = time.time()   df = useir.csolve_uSeir(dist = \"gamma\",                     ti_shape     = 2,                      ti_scale     = 4,                      tr_shape     = 2,                      tr_scale     = 3,                      R0           = 3.5   )   end = time.time()    cython_runs = cython_runs + [end - start] ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 # ---- Get output for uSEIR ----- df = useir.csolve_uSeir(dist = \"gamma\",                     ti_shape     = 2,                      ti_scale     = 4,                      tr_shape     = 2,                      tr_scale     = 3,                      R0           = 3.5,                      pde_sampling = \"\"   ) ##  Function compute_pde with sampling = , time epsilon = 0.1 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 470, infected compartments = 352 ## len pdE = 470, max(pdE) =0.009196039895832842 len pdi = 352 max(pdI) =0.01226041465028943 ## prob = 0.5833333333333334, pn = 0.05833333333333334 # convert to pyarrow table for easy conversion to R data.frames to_r_df = pa.Table.from_pandas(df) ##  [1] 0.4204161 0.4766951 0.4147639 0.4129088 0.4140410 0.4138477 0.4130261 ##  [8] 0.4212909 0.4190290 0.4190660 0.4167402 0.4169221 0.4223282 0.4214261 ## [15] 0.4183862 0.4258659 0.4213421 0.4203939 0.4140539 0.4189341 0.4143560 ## [22] 0.4160459 0.4132569 0.4258149 0.4234819 0.4231689 0.4148700 0.4118659 ## [29] 0.4141519 0.4160001 0.4115329 0.4168539 0.4263620 0.4209700 0.4172430 ## [36] 0.4104204 0.4120522 0.4208171 0.4225249 0.4185033 0.4216430 0.4290931 ## [43] 0.4313729 0.4218540 0.4188001 0.4174929 0.4225781 0.4190321 0.4265318 ## [50] 0.4230540"},{"path":"/articles/denim_benchmark.html","id":"desolve","dir":"Articles","previous_headings":"","what":"2. deSolve","title":"denim benchmark","text":"Simulate model using deSolve package (Soetaert, Petzoldt, Setzer 2008)","code":""},{"path":"/articles/denim_benchmark.html","id":"model-in-r","dir":"Articles","previous_headings":"2. deSolve","what":"2.1. Model in R","title":"denim benchmark","text":"Run time deSolve implementation Median run time deSolve, model defined R: 0.0034217 seconds","code":"library(deSolve) ## Warning: package 'deSolve' was built under R version 4.3.1 parameters <- c(gamma_rate_I = 1/4, shape_I=2,                 gamma_rate_R = 1/3, shape_R = 2,                 R0 = 3.5, N = 1e6)  initialValues <- c(S = 999999, E1 = 1,                    E2 = 0, E = 0, I1=0,                     I2=0, I=0, R=0                    )  # --- Transition def for deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {       tr = shape_R*(1/gamma_rate_R)              dS = - (R0/tr) * S * I/N       # apply linear chain trick       dE1 = (R0/tr) * S * I/N - gamma_rate_I*E1       dE2 = gamma_rate_I*E1 - gamma_rate_I*E2       dE = dE1 + dE2       dI1 = gamma_rate_I*E2 - gamma_rate_R*I1       dI2 = gamma_rate_R*I1 - gamma_rate_R*I2       dI =  dI1 + dI2        dR = gamma_rate_R*I2       list(c(dS, dE1, dE2, dE, dI1, dI2, dI, dR))   }) }  times <- seq(0, sim_duration, 1)  # ------ Compute run time ------ desolve_runs <- if(is.null(cached_runtime)){   bench::mark(     ode(y = initialValues, times = times, parms = parameters, func = transition_func),     iterations = total_runs   )$time[[1]] }else{   cached_runtime$desolve_runs }  ode_mod <- ode(y = initialValues, times = times, parms = parameters, func = transition_func) ode_mod <- as.data.frame(ode_mod) ##  [1] 0.005304047 0.004200286 0.004217916 0.004035220 0.004270765 0.012629353 ##  [7] 0.003946947 0.003625876 0.003706810 0.003715584 0.003655396 0.003381270 ## [13] 0.003337974 0.003452651 0.003362410 0.003279467 0.003470978 0.003516816 ## [19] 0.003786965 0.003310299 0.003598119 0.004339440 0.003422598 0.003559620 ## [25] 0.009443735 0.003371717 0.003420794 0.003429978 0.003207963 0.003452446 ## [31] 0.003531986 0.003424648 0.003343099 0.003396727 0.003252735 0.003071433 ## [37] 0.003125102 0.003217844 0.003100502 0.003192178 0.003369790 0.003283485 ## [43] 0.003259951 0.003304641 0.008277367 0.003261550 0.003233014 0.003116533 ## [49] 0.003167250 0.003189923 ## attr(,\"class\") ## [1] \"bench_time\" \"numeric\""},{"path":"/articles/denim_benchmark.html","id":"model-in-c","dir":"Articles","previous_headings":"2. deSolve","what":"2.2. Model in C","title":"denim benchmark","text":"Run time deSolve model defined C Median run time deSolve, model defined C: 1.267105^{-4} seconds","code":"# compile model # system(\"R CMD SHLIB supplements/desolve_mod/benchmark_mod.c\")  # compiled file on Windows will have .dll extension instead of .so dyn.load(\"../supplements/desolve_mod/benchmark_mod.so\")  initialValues <- c(S = 999999, E1 = 1,                    E2 = 0, E = 0, I1=0,                     I2=0, I=0, R=0                    )  parameters <- c(R0 = 3.5, scale_I = 4, shape_I=2,                 scale_R = 3, shape_R = 2, N = 1e6)   desolve_c_runs <- if(is.null(cached_runtime)){   bench::mark(     # run model defined in C     ode(initialValues, times, func = \"derivs\", parms = parameters,     dllname = \"benchmark_mod\", initfunc = \"initmod\"),     iterations = total_runs   )$time[[1]] }else{   cached_runtime$desolve_c_runs }  dyn.unload(\"../supplements/desolve_mod/benchmark_mod.so\") desolve_c_runs ##  [1] 0.000195447 0.000139072 0.000399422 0.000122426 0.000197907 0.000121032 ##  [7] 0.000118285 0.000171790 0.000116112 0.000162278 0.000117178 0.000122426 ## [13] 0.000162032 0.000122057 0.000162237 0.000114595 0.000114841 0.000155062 ## [19] 0.000113652 0.000162237 0.000116645 0.000125993 0.000158875 0.000124558 ## [25] 0.000157276 0.000112668 0.000118859 0.000154857 0.000127510 0.000152479 ## [31] 0.000113734 0.000126854 0.000161212 0.000123000 0.000154611 0.000119802 ## [37] 0.000121114 0.000161622 0.000118367 0.000158957 0.000118695 0.000126567 ## [43] 0.000157563 0.000127756 0.000156497 0.000121893 0.000114636 0.000165066 ## [49] 0.000119597 0.000161089 ## attr(,\"class\") ## [1] \"bench_time\" \"numeric\""},{"path":"/articles/denim_benchmark.html","id":"model-in-fortran","dir":"Articles","previous_headings":"2. deSolve","what":"2.3. Model in Fortran","title":"denim benchmark","text":"Median run time deSolve, model defined Fortran: 1.789855^{-4} seconds","code":"# compile model in fortran # system(\"R CMD SHLIB supplements/desolve_mod/benchmark_mod_fortran.f\")  dyn.load(\"../supplements/desolve_mod/benchmark_mod_fortran.so\")  initialValues <- c(S = 999999, E1 = 1,                    E2 = 0, E = 0, I1=0,                     I2=0, I=0, R=0                    )  parameters <- c(R0 = 3.5, scale_I = 4, shape_I=2,                 scale_R = 3, shape_R = 2, N = 1e6)   desolve_fortran_runs <- if(is.null(cached_runtime)){   bench::mark(     # run model defined in Fortran     ode(initialValues, times, func = \"derivs\", parms = parameters,     dllname = \"benchmark_mod_fortran\", initfunc = \"initmod\"),     iterations = total_runs   )$time[[1]] }else{   cached_runtime$desolve_fortran_runs }  dyn.unload(\"../supplements/desolve_mod/benchmark_mod_fortran.so\") desolve_fortran_runs ##  [1] 0.000305942 0.000602536 0.000193807 0.000299710 0.000181056 0.000173061 ##  [7] 0.000247599 0.000164656 0.000215742 0.000166747 0.000161868 0.000208321 ## [13] 0.000173389 0.000215701 0.000167936 0.000163385 0.000206435 0.000170519 ## [19] 0.000203647 0.000159572 0.000162073 0.000200982 0.000157891 0.000203524 ## [25] 0.000167075 0.000175644 0.000212257 0.000164656 0.000217628 0.000162483 ## [31] 0.000160269 0.000207788 0.000165845 0.000209715 0.000164000 0.000158178 ## [37] 0.000216357 0.000183065 0.000236816 0.000176915 0.000183270 0.000207583 ## [43] 0.000166911 0.000204057 0.000168510 0.000173266 0.000214020 0.000169207 ## [49] 0.000208813 0.000159900 ## attr(,\"class\") ## [1] \"bench_time\" \"numeric\""},{"path":"/articles/denim_benchmark.html","id":"ionise","dir":"Articles","previous_headings":"","what":"3. IONISE","title":"denim benchmark","text":"Simulate model using IONISE approach (Hong et al. 2024). Source code: https://github.com/Mathbiomed/IONISE Median run time IONISE: 0.0515998 seconds","code":"# load code for IONISE source(\"../supplements/ionise_mod/IONISE.R\") ## Warning: package 'invgamma' was built under R version 4.3.3 # ------ Set up ------- ionise_time <- seq(0, sim_duration, 1) ionise_params <- c(   3.5/6, # beta    2, 4, # rate and shape E -> I transition   2, 3 # rate and shape I -> R transition ) inonise_init <-  c(S_init = 999999, E_init = 1, I_init = 0, R_init = 0)  # ------ Compute run time ------ ionise_runs <- if(is.null(cached_runtime)){   bench::mark(     # run model defined using IONISE     mean_trajectory_SEIR_dist_input(       timespan = ionise_time,       theta = ionise_params,       y_init = inonise_init,       dist_type = \"gamma\"     ),     iterations = total_runs   )$time[[1]] }else{   cached_runtime$ionise_runs }  # ----- Format output ------  ionise_out <- mean_trajectory_SEIR_dist_input(   timespan = ionise_time,   theta = ionise_params,   y_init = inonise_init,   dist_type = \"gamma\" ) %>% as.data.frame() %>%    rename(     S = St,     E = Et,     I = It,     R = Rt   ) %>%    mutate(     time = ionise_time   ) ionise_runs ##  [1] 0.06817070 0.05149485 0.05189616 0.05826383 0.05112364 0.05867895 ##  [7] 0.05057096 0.05153241 0.12881015 0.05100023 0.05732948 0.05045144 ## [13] 0.05128989 0.05709283 0.05034919 0.05779532 0.05209374 0.05119198 ## [19] 0.05720627 0.05115365 0.05116361 0.05699221 0.05041499 0.05767786 ## [25] 0.05027904 0.05104139 0.05675511 0.04968548 0.05187390 0.05704781 ## [31] 0.05065263 0.05773714 0.05060056 0.05073750 0.05742308 0.05149723 ## [37] 0.05251399 0.05981601 0.05161666 0.05888576 0.05061868 0.05158292 ## [43] 0.05758171 0.05078067 0.05907190 0.05111150 0.05140580 0.05803812 ## [49] 0.05099039 0.05164077 ## attr(,\"class\") ## [1] \"bench_time\" \"numeric\""},{"path":"/articles/denim_benchmark.html","id":"diffeqr","dir":"Articles","previous_headings":"","what":"4. diffeqr","title":"denim benchmark","text":"Simulate model using diffeqr package (Rackauckas, n.d.)","code":""},{"path":"/articles/denim_benchmark.html","id":"model-in-r-1","dir":"Articles","previous_headings":"4. diffeqr","what":"4.1. Model in R","title":"denim benchmark","text":"Setup Julia diffeqr Set SEIR model Median run time diffeqr base solver: 0.0020887 seconds","code":"# load library library(diffeqr)  # uncomment to check Julia version # JuliaCall::julia_command(\"VERSION\") # uncomment to resolve error: type RFunction has no field r # JuliaCall::julia_command('using Pkg; Pkg.add(PackageSpec(name = \"ModelingToolkit\", version = \"8.76.0\"))') # uncomment to check installed packages version # JuliaCall::julia_command('using Pkg; Pkg.installed()') # --- Transition def for diffeqr ------  diffeqr_transition <- function(u, p, t){   # p - gamma_rate_I, shape_I, gamma_rate_R, shape_R, R0, N   # u - S, E1, E2, E, I1, I2, I, R   tr = p[4]*(1/p[3])      dS = - (p[5]/tr) * u[1] * u[7]/p[6]   # apply linear chain trick   dE1 = (p[5]/tr) * u[1] * u[7]/p[6] - p[1]*u[2]   dE2 = p[1]*u[2] - p[1]*u[3]   dE = dE1 + dE2   dI1 = p[1]*u[3] - p[3]*u[5]   dI2 = p[3]*u[5] - p[3]*u[6]   dI =  dI1 + dI2    dR = p[3]*u[6]      return(c(dS, dE1, dE2, dE, dI1, dI2, dI, dR)) }  diffeqr_time <- c(0, sim_duration)  # ---- Parameter setup ----- parameters <- c(gamma_rate_I = 1/4, shape_I=2,                 gamma_rate_R = 1/3, shape_R = 2,                 R0 = 3.5, N = 1e6)  initialValues <- c(S = 999999, E1 = 1,                    E2 = 0, E = 0, I1=0,                     I2=0, I=0, R=0                    )  # set up diffeqr solverr setup <- diffeq_setup() ## Julia version 1.9.4 at location /Users/anhptq/Library/Application Support/org.R-project.R/R/JuliaCall/julia/1.9.4/julia-1.9.4/bin will be used. ## Loading setup script for JuliaCall... ## Finish loading setup script for JuliaCall. # we can use initialValues and parameters set up for deSolve diffeqr_mod <- setup$ODEProblem(diffeqr_transition,                                  initialValues,                                 diffeqr_time,                                  parameters)   # ------ Compute run time ------ diffeqr_base_runs <- if(is.null(cached_runtime)){   bench::mark(     setup$solve(diffeqr_mod),     iterations = total_runs   )$time[[1]] }else{   cached_runtime$diffeqr_base_runs }  # ----- Format output ------  sol <- setup$solve(diffeqr_mod) out_mat <- sapply(sol$u,identity) # convert to data.frame diffeqr_out <- as.data.frame(t(out_mat)) # add names names(diffeqr_out) <- names(initialValues) # add time column diffeqr_out <- diffeqr_out %>% mutate(     time = identity(sol$t)   ) diffeqr_base_runs ##  [1] 0.002693413 0.002484805 0.002288702 0.002978978 0.002667460 0.002320682 ##  [7] 0.002303790 0.002602516 0.002445568 0.002196616 0.002118142 0.002151434 ## [13] 0.002274475 0.002166645 0.002083292 0.002099159 0.002242372 0.002268038 ## [19] 0.002162381 0.002131016 0.002185177 0.002274352 0.002062259 0.002014535 ## [25] 0.001937906 0.001981366 0.002181487 0.002094198 0.002041759 0.001970624 ## [31] 0.004588023 0.002119905 0.001975503 0.001952133 0.001925770 0.001989361 ## [37] 0.001940612 0.002008836 0.001933355 0.001972879 0.001980505 0.001998709 ## [43] 0.001989566 0.002060619 0.002003342 0.001982473 0.001994404 0.001954265 ## [49] 0.002002440 0.001978865 ## attr(,\"class\") ## [1] \"bench_time\" \"numeric\""},{"path":"/articles/denim_benchmark.html","id":"define-model-in-julia","dir":"Articles","previous_headings":"4. diffeqr","what":"4.2. Define model in Julia","title":"denim benchmark","text":"can tell diffeqr define model Julia, can utilize Julia JIT compiler can improve runtime. Median run time IONISE: 1.025205^{-4} seconds","code":"# define model in Julia instead optimized_mod <- diffeqr::jitoptimize_ode(setup, diffeqr_mod)  diffeqr_optimized_runs <- if(is.null(cached_runtime)){   bench::mark(     solve(optimized_mod, setup$Tsit5()),     iterations = total_runs   )$time[[1]] }else{   cached_runtime$diffeqr_optimized_runs } diffeqr_optimized_runs ##  [1] 0.000206886 0.000160638 0.000143377 0.000120294 0.000098236 0.000117506 ##  [7] 0.000127264 0.000111438 0.000104878 0.000106682 0.000099917 0.000109019 ## [13] 0.000103771 0.000102090 0.000142680 0.000095120 0.000121483 0.000105739 ## [19] 0.000107953 0.000107338 0.000096965 0.000107502 0.000104017 0.000094136 ## [25] 0.000102951 0.000120089 0.000126977 0.000115784 0.000110577 0.000099671 ## [31] 0.000111192 0.000112381 0.000083476 0.000091020 0.000101926 0.000090200 ## [37] 0.000084132 0.000091717 0.000090487 0.000093521 0.000088970 0.000083763 ## [43] 0.000094505 0.000096145 0.000090159 0.000091635 0.000086100 0.000087248 ## [49] 0.000094710 0.000082697 ## attr(,\"class\") ## [1] \"bench_time\" \"numeric\""},{"path":"/articles/denim_benchmark.html","id":"sec-odin","dir":"Articles","previous_headings":"","what":"5. odin","title":"denim benchmark","text":"also implement uSEIR model denim’s algorithm using odin package (FitzJohn et al. 2024) comparison Run model bench mark. Note process computing transition probability also included part benchmark fair comparison denim. Median run time odin: 0.3263736 seconds","code":"# ---- Install packages ----- # install.packages( #   \"odin2\", #   repos = c(\"https://mrc-ide.r-universe.dev\", \"https://cloud.r-project.org\")) # install.packages( #   \"dust2\", #   repos = c(\"https://mrc-ide.r-universe.dev\", \"https://cloud.r-project.org\")) library(odin2)  odin_mod <- odin2::odin(   {     # ----- Define algo to update compartments here ---------     update(S) <- S - dt * (R0/tr) * S * sum(I)/N      # --- E compartment ------     update(E[1]) <- dt * (R0/tr) * S * sum(I)/N     # starting from 2: to simulate individuals staying in E for another timestep     update(E[2:e_maxtime]) <- E[i-1]*(1-e_transprob[i-1])          # compute total population from E -> I     dim(E_to_I) <- e_maxtime     E_to_I[1:e_maxtime] <- e_transprob[i]*E[i]     sum_E_to_I <- sum(E_to_I)          # --- I compartment ------     update(I[1]) <- sum_E_to_I     update(I[2:i_maxtime]) <- I[i-1]*(1-i_transprob[i-1])          # compute total population from I -> R     dim(I_to_R) <- i_maxtime     I_to_R[1:i_maxtime] <- i_transprob[i]*I[i]     sum_I_to_R <- sum(I_to_R)      # --- R compartment ------     update(R) <- R + sum_I_to_R          # initialize population from input     initial(S) <- S_init     initial(E[]) <- E_init[i]     dim(E) <- e_maxtime     initial(I[]) <- I_init[i]     dim(I) <- i_maxtime     initial(R) <- R_init      # ----- Inputs -------     R0 <- parameter()     tr <- parameter()          # transition prob of E     e_transprob<- parameter()     e_maxtime <- parameter()     dim(e_transprob) <- e_maxtime          # transition prob of I     i_transprob <- parameter()     i_maxtime <- parameter()     dim(i_transprob) <- i_maxtime               # initial populations     S_init <- user()     E_init <- user()     dim(E_init) <- e_maxtime     I_init <- user()     dim(I_init) <- i_maxtime     R_init <- user()     N <- parameter(1000)   } ) ## Warning in odin2::odin({: Found 4 compatibility issues ## Replace calls to 'user()' with 'parameter()' ## ✖ S_init <- user() ## ✔ S_init <- parameter() ## ✖ E_init <- user() ## ✔ E_init <- parameter() ## ✖ I_init <- user() ## ✔ I_init <- parameter() ## ✖ R_init <- user() ## ✔ R_init <- parameter() ## ── R CMD INSTALL ─────────────────────────────────────────────────────────────── ## * installing *source* package ‘odin.system79e020ca’ ... ## ** using staged installation ## ** libs ## using C++ compiler: ‘Apple clang version 17.0.0 (clang-1700.0.13.5)’ ## using SDK: ‘NA’ ## clang++ -arch arm64 -std=gnu++17 -I\"/Library/Frameworks/R.framework/Resources/include\" -DNDEBUG -O2 -I'/Users/anhptq/Library/R/arm64/4.3/library/cpp11/include' -I'/Users/anhptq/Library/R/arm64/4.3/library/dust2/include' -I'/Users/anhptq/Library/R/arm64/4.3/library/monty/include' -I/opt/R/arm64/include   -DHAVE_INLINE   -fPIC  -isystem /Library/Developer/CommandLineTools/SDKs/MacOSX15.5.sdk/usr/include/c++/v1 -O2 -c cpp11.cpp -o cpp11.o ## clang++ -arch arm64 -std=gnu++17 -I\"/Library/Frameworks/R.framework/Resources/include\" -DNDEBUG -O2 -I'/Users/anhptq/Library/R/arm64/4.3/library/cpp11/include' -I'/Users/anhptq/Library/R/arm64/4.3/library/dust2/include' -I'/Users/anhptq/Library/R/arm64/4.3/library/monty/include' -I/opt/R/arm64/include   -DHAVE_INLINE   -fPIC  -isystem /Library/Developer/CommandLineTools/SDKs/MacOSX15.5.sdk/usr/include/c++/v1 -O2 -c dust.cpp -o dust.o ## clang++ -arch arm64 -std=gnu++17 -dynamiclib -Wl,-headerpad_max_install_names -undefined dynamic_lookup -single_module -multiply_defined suppress -L/Library/Frameworks/R.framework/Resources/lib -L/Library/Developer/CommandLineTools/SDKs/MacOSX15.5.sdk/usr/lib -L/opt/homebrew/opt/libomp/lib -lomp -o odin.system79e020ca.so cpp11.o dust.o -F/Library/Frameworks/R.framework/.. -framework R -Wl,-framework -Wl,CoreFoundation ## ld: warning: -single_module is obsolete ## ld: warning: -multiply_defined is obsolete ## installing to /private/var/folders/rf/dwxhm19j1ws1mfmsvj9yfp140000gr/T/Rtmp8YtIhU/devtools_install_562046b3b43b/00LOCK-dust_56203016df34/00new/odin.system79e020ca/libs ## ** checking absolute paths in shared objects and dynamic libraries ## * DONE (odin.system79e020ca) compute_transprob <- function(dist_func,..., timestep=0.05, error_tolerance=0.001){   maxtime <- timestep   prev_prob <- 0   transprob <- numeric()   cumulative_dist <- numeric()   prob_dist <- numeric()      while(TRUE){      # get current cumulative prob and check whether it is sufficiently close to 1      temp_prob <-  ifelse(        dist_func(maxtime, ...) < (1 - error_tolerance),         dist_func(maxtime, ...),         1);      cumulative_dist <- c(cumulative_dist, temp_prob)            # get f(t)      curr_prob <- temp_prob - prev_prob      prob_dist <- c(prob_dist, curr_prob)            # compute transprob      curr_transprob <- curr_prob/(1-prev_prob)      transprob <- c(transprob, curr_transprob)            prev_prob <- temp_prob      maxtime <- maxtime + timestep            if(temp_prob == 1){        break      }   }      data.frame(     prob_dist = prob_dist,     cumulative_dist = cumulative_dist,     transprob = transprob   ) } timeStep <- 0.01 errorTolerance <- 0.001  run_useir_odin <- function(){   # ---- Compute transprob -----    e_transprob <- compute_transprob(pgamma, rate=1/4, shape=2,                                     timestep = timeStep, error_tolerance = errorTolerance)$transprob   i_transprob <- compute_transprob(pgamma, rate=1/3, shape=2,                                     timestep = timeStep, error_tolerance = errorTolerance)$transprob      # ---- Run model and plot -----    # initialize params   odin_pars <- list(     R0 = 3.5,      tr = 3*2, # compute mean recovery time, for gamma it's scale*shape     N = 1e6,     e_transprob = e_transprob,     e_maxtime = length(e_transprob),     i_transprob = i_transprob,     i_maxtime = length(i_transprob),     S_init = 999999,      E_init = array( c(1, rep(0, length(e_transprob) - 1) ) ),     I_init = array( rep(0, length(i_transprob)) ),     R_init = 0   )      # run model   t_seq <- seq(0, sim_duration, 0.25)   odin_seir <- dust2::dust_system_create(odin_mod, odin_pars, dt = timeStep)   dust2::dust_system_set_state_initial(odin_seir)   out <- dust2::dust_system_simulate(odin_seir, t_seq)   out <- dust2::dust_unpack_state(odin_seir, out)      data.frame(     t = t_seq,     S = out$S,     E = colSums(out$E),     I = colSums(out$I),     R = out$R   ) }  # ---- Get runtimes ---- odin_runs <- if(is.null(cached_runtime)){   bench::mark({       run_useir_odin()     },     iterations = total_runs   )$time[[1]] }else{   cached_runtime$odin_runs }  odin_out <- run_useir_odin() odin_runs ##  [1] 0.5072996 0.3424156 0.3366308 0.3406740 0.3330703 0.3335009 0.3217610 ##  [8] 0.3240203 0.3427259 0.4706479 0.3299392 0.3304285 0.3329552 0.3304867 ## [15] 0.3227320 0.3148952 0.3188499 0.3263258 0.3322886 0.3458588 0.3416245 ## [22] 0.3289546 0.3243573 0.3258650 0.3250313 0.3172627 0.3248926 0.3226293 ## [29] 0.3343968 0.3240186 0.3258362 0.3262575 0.3263672 0.3289742 0.3287218 ## [36] 0.3273383 0.3233925 0.3302466 0.3367000 0.3328990 0.3254890 0.3263295 ## [43] 0.3284959 0.3263799 0.3236712 0.3167945 0.3160050 0.3201000 0.3245766 ## [50] 0.3249563 ## attr(,\"class\") ## [1] \"bench_time\" \"numeric\""},{"path":[]},{"path":"/articles/denim_benchmark.html","id":"parametric","dir":"Articles","previous_headings":"6. denim","what":"6.1. Parametric","title":"denim benchmark","text":"Run time denim implementation Median run time denim: 0.7617914 seconds","code":"timeStep <- 0.01 errorTolerance <- 0.001  library(denim)  denim_model <- denim_dsl({   S -> E = (R0/tr) * S * (I/N)    E -> I = d_gamma(rate = 1/4, shape = 2)   I -> R = d_gamma(rate = 1/3, shape = 2) })  initialValues <- c(S = 999999, E = 1, I= 0, R= 0) parameters <- c(R0 = 3.5,                  tr = 3*2, # compute mean recovery time, for gamma it's scale*shape                 N = 1e6)  # ---- Get runtimes ---- denim_runs <- if(is.null(cached_runtime)){   bench::mark(     sim(       transitions = denim_model,       initialValues = initialValues,       parameters = parameters,       simulationDuration = sim_duration,       timeStep = timeStep,       errorTolerance = errorTolerance     ),      iterations = total_runs   )$time[[1]] }else{   cached_runtime$denim_runs }   # ---- Get output ---- denim_out <- sim(transitions = denim_model,                       initialValues = initialValues,                      parameters = parameters,                      simulationDuration = sim_duration, timeStep = timeStep) plot(denim_out) denim_runs ##  [1] 0.7775783 0.7658625 0.7658219 0.7527552 0.7504584 0.7459896 0.7538721 ##  [8] 0.7526610 0.7520982 0.7547207 0.7684007 0.7547187 0.7472895 0.7434827 ## [15] 0.7453847 0.7496407 0.7483962 0.7436754 0.7430848 0.7642120 0.7660060 ## [22] 0.7527885 0.7441409 0.7522371 0.7532427 0.7507179 0.7445365 0.7521483 ## [29] 0.7599063 0.7734088 0.7610964 0.7719678 0.7829652 0.7754629 0.7685974 ## [36] 0.7661460 0.7734480 0.7711797 0.7823685 0.7821349 0.7743654 0.7751355 ## [43] 0.7751941 0.7624863 0.7716902 0.7782576 0.7795323 0.7513516 0.7737280 ## [50] 0.7791423 ## attr(,\"class\") ## [1] \"bench_time\" \"numeric\""},{"path":"/articles/denim_benchmark.html","id":"nonparametric","dir":"Articles","previous_headings":"6. denim","what":"6.2. Nonparametric","title":"denim benchmark","text":"can also define SEIR model denim using function nonparametric() dwell-time distribution pre-computed using helper function Section @ref(sec-odin) Run time denim, using nonparametric() pre-computed distribution Median run time denim using nonparametric() pre-computed distribution: 1.2231959 seconds. longer run time compared parametric approach due overhead interfacing large vectors (ei_dist ir_dist example) R C++. reason, recommended use nonparametric() observed distribution adequately represented one available parametric transitions.","code":"timeStep <- 0.01 errorTolerance <- 0.001  denim_nonparametric_model <- denim_dsl({   S -> E = (R0/tr) * S * (I/N)    E -> I = nonparametric(ei_dist) #ei_dist is considered a model parameter   I -> R = nonparametric(ir_dist) #ir_dist is also a model parameter })  initialValues2 <- c(S = 999999, E = 1, I= 0, R= 0)  ei_dist <- compute_transprob(pgamma, rate = 1/4, shape = 2,                               timestep = timeStep, error_tolerance = errorTolerance)$prob_dist ir_dist <- compute_transprob(pgamma, rate = 1/3, shape = 2,                               timestep = timeStep, error_tolerance = errorTolerance)$prob_dist  parameters2 <- list(R0 = 3.5,                  tr = 3*2, # compute mean recovery time, for gamma it's scale*shape                 N = 1e6,                 ei_dist = ei_dist,                  ir_dist = ir_dist)  # ---- Get runtimes ---- denim_nonparametric_runs <- if(is.null(cached_runtime)){   bench::mark(     sim(transitions = denim_nonparametric_model,                        initialValues = initialValues2,                        parameters = parameters2,                        simulationDuration = sim_duration, timeStep = timeStep),     iterations = total_runs   )$time[[1]] }else{   cached_runtime$denim_nonparametric_runs }  # ---- Get output ---- denim_nonparametric_out <- sim(transitions = denim_nonparametric_model,                       initialValues = initialValues2,                      parameters = parameters2,                      simulationDuration = sim_duration, timeStep = timeStep) denim_nonparametric_runs ##  [1] 1.231386 1.364033 1.213625 1.203059 1.360039 1.190269 1.179894 1.335714 ##  [9] 1.180204 1.173921 1.388920 1.196026 1.213411 1.355098 1.220042 1.209340 ## [17] 1.354528 1.218138 1.211499 1.356084 1.214659 1.200451 1.373566 1.206884 ## [25] 1.202324 1.370221 1.195023 1.223129 1.378572 1.291881 1.263136 1.487639 ## [33] 1.301094 1.289617 1.419765 1.212522 1.199191 1.390638 1.232883 1.197724 ## [41] 1.360732 1.216516 1.223262 1.375848 1.201429 1.200430 1.334362 1.213480 ## [49] 1.227435 1.360499 ## attr(,\"class\") ## [1] \"bench_time\" \"numeric\""},{"path":"/articles/denim_benchmark.html","id":"visualize-output","dir":"Articles","previous_headings":"","what":"7. Visualize output","title":"denim benchmark","text":"plot compare output discrete time frameworks (odin, denim, uSEIR) continuous time solver deSolve.","code":""},{"path":"/articles/denim_benchmark.html","id":"compare-run-time","dir":"Articles","previous_headings":"","what":"8. Compare run time","title":"denim benchmark","text":"following plot shows run time 50 runs (horizontal line showing median run time) approach.","code":""},{"path":[]},{"path":"/articles/denim_benchmark.html","id":"run-time-scaling","dir":"Articles","previous_headings":"9. Impact of timeStep in denim","what":"9.1. Run time scaling","title":"denim benchmark","text":"worth noting runtime denim also dependent duration time step (timeStep parameter sim). following plot demonstrates run time changes value timeStep changes, using model benchmarking. values timeStep evaluated [0.01, 0.02, 0.05, 0.1, 0.25, 0.5, 1].","code":""},{"path":"/articles/denim_benchmark.html","id":"impact-on-accuracy","dir":"Articles","previous_headings":"9. Impact of timeStep in denim","what":"9.2. Impact on accuracy","title":"denim benchmark","text":"Aside run time, duration time step also impacts accuracy denim’s output. following plots demonstrates precision compromised increase duration time step (output deSolve used baseline). values timeStep evaluated [0.01, 0.1, 0.5, 1].","code":""},{"path":"/articles/denim_dsl.html","id":"model-definition-in-denim","dir":"Articles","previous_headings":"","what":"Model definition in denim","title":"denim DSL","text":"denim, model defined set transitions compartments. transition provided form key-value pair, : key show transition direction 2 compartments. value expression describe transition, can math expression built-dwell-time distribution function. key-value pairs can provided 2 ways Using denim domain-specific language (DSL). Define list R.","code":""},{"path":"/articles/denim_dsl.html","id":"denim-dsl","dir":"Articles","previous_headings":"","what":"Denim DSL","title":"denim DSL","text":"denim, line code must transition. syntax defining transition denim DSL followed: compartment_A -> compartment_B = transition Model definition written denim DSL must parsed function denim_dsl() Math expression math expression, basic supported operators include: + addition, - minus, * multiplication, / division, ^ power. Users can also define additional model parameters math expression. Math expressions denim parsed using muparser. full list operators, visit muparser website https://beltoforion.de/en/muparser/features.php. Distribution functions Several built-functions provided describe transitions based distribution dwell time: parametric distributions: d_lognormal(), d_gamma(), d_weibull(), d_exponential() non-parametric distributions: nonparametric() functions accepts either fixed numerical values model parameters inputs distributional parameters.","code":""},{"path":"/articles/denim_dsl.html","id":"define-a-classic-sir-model","dir":"Articles","previous_headings":"Denim DSL","what":"Define a classic SIR model","title":"denim DSL","text":"classic SIR model can defined denim followed denim_dsl() parses given expression return R list followed. example, model parameters : N, beta, gamma. Users can also choose provide fixed values distributional parameter followed. Similar R, users can also add comments denim DSL starting comment # sign. Run model run model, users must provide: Values model parameters (example, N, beta, gamma). Initial population compartments. Simulation configurations. Parameters initial values can defined named vectors named lists R. Simulation configurations provided parameters sim() function runs model, : timeStep duration time step model. simulationDuration duration run simulation.","code":"sir_model <- denim_dsl({   S -> I = beta * (I/N) * S   I -> R = d_exponential(rate = gamma) }) sir_model #> $`S -> I` #> [1] \"beta * (I/N) * S\" #>  #> $`I -> R` #> Discretized exponential distribution #> Rate = gamma #>  #> attr(,\"class\") #> [1] \"denim_transition\" sir_model <- denim_dsl({   S -> I = beta*(I/N)*S   I -> R = d_exponential(rate = 1/4) }) sir_model <- denim_dsl({   # this is a comment   S -> I = beta*(I/N)*S   I -> R = d_exponential(rate = 1/4) # this is another comment }) # parameters for the model parameters <- c(   beta = 0.4,   N = 1000,   gamma = 1/7 ) # initial population for each compartment  initValues <- c(   S = 999,    I = 50,   R = 0 ) mod <- sim(sir_model,      parameters = parameters,      initialValues = initValues,      timeStep = 0.01,     simulationDuration = 40) plot(mod, ylim = c(1, 1000))"},{"path":"/articles/denim_dsl.html","id":"time-varying-transition","dir":"Articles","previous_headings":"Denim DSL","what":"Time varying transition","title":"denim DSL","text":"variable time special variable denim time varying transition (e.g. modeling seasonality). Note variable can used within math expression. Example: time varying transition","code":"time_varying_mod <- denim_dsl({   A -> B = 20 * (1+cos(omega * time))  })  # parameters for the model parameters <- c(   omega = 2*pi/10 ) # initial population for each compartment  initValues <- c(A = 1000, B = 0)  mod <- sim(time_varying_mod,      parameters = parameters,      initialValues = initValues,      timeStep = 0.01,     simulationDuration = 40)  plot(mod, ylim = c(0, 1000))"},{"path":"/articles/denim_dsl.html","id":"r-list","dir":"Articles","previous_headings":"","what":"R list","title":"denim DSL","text":"Users can define model structure directly list R. example, SIR model previous example can represented followed. Note transitions (S -> , -> R), mathematical expression (beta * (/N) * S), model parameter (gamma) must now provided strings. can run model manner previously demonstrated.  define model list R? denim DSL offers cleaner readable syntax define model structure, using R list may familiar R users better suited integration R-centric workflow. example, consider use case , explore model dynamics change three different -> R dwell time distributions (d_gamma, d_weibull, d_lognormal) using map2.","code":"sir_model_list <- list(   \"S -> I\" = \"beta * (I/N) * S\",   \"I -> R\" = d_exponential(rate = \"gamma\") )  sir_model_list #> $`S -> I` #> [1] \"beta * (I/N) * S\" #>  #> $`I -> R` #> Discretized exponential distribution #> Rate = gamma # parameters for the model parameters <- c(   beta = 0.4,   N = 1000,   gamma = 1/7 ) # initial population for each compartment  initValues <- c(   S = 999,    I = 50,   R = 0 ) # run the simulation mod <- sim(sir_model_list,      parameters = parameters,      initialValues = initValues,      timeStep = 0.01,     simulationDuration = 40) # plot output plot(mod, ylim = c(1, 1000)) library(tidyverse) #> Warning: package 'ggplot2' was built under R version 4.3.1 #> Warning: package 'tidyr' was built under R version 4.3.1 #> Warning: package 'readr' was built under R version 4.3.1 #> Warning: package 'purrr' was built under R version 4.3.3 #> Warning: package 'dplyr' was built under R version 4.3.1 #> Warning: package 'stringr' was built under R version 4.3.1 #> Warning: package 'lubridate' was built under R version 4.3.3 # configurations for 3 different I->R transitions model_config <- tibble(   IR_dists = c(d_gamma, d_weibull, d_lognormal),   IR_pars = list(c(rate = 0.1, shape = 3), c(scale = 5, shape = 0.3), c(mu = 0.3, sigma = 2)) )  walk2(   model_config$IR_dists, model_config$IR_pars, \\(dist, par){     transitions <- list(       \"S -> I\" = \"beta * S * (I / N)\",       # This is not applicable when using denim_dsl()       \"I -> R\" = do.call(dist, as.list(par))     )          # model settings     denimInitialValues <- c(S = 980, I = 20, R = 0)     parameters <- c(       beta = 0.4,       N = 1000     )          # compare output      mod <- sim(transitions = transitions,                 initialValues = denimInitialValues,                 parameters = parameters,                 simulationDuration = 60,                 timeStep = 0.05)          plot(mod, ylim = c(0,1000)) })"},{"path":"/articles/denim_vs_deSolve.html","id":"comparison-between-desolve-and-denim","dir":"Articles","previous_headings":"","what":"Comparison between deSolve and denim","title":"denim vs deSolve","text":"","code":"library(denim) library(deSolve) ## Warning: package 'deSolve' was built under R version 4.3.1 # --- Timestep definition simulationDuration <- 300  timestep <- 0.01 # small timestep required for comparison  # --- Transition def for denim transitions <- list(   # note that timeStep uses the timeStep parameter in denim::sim()    \"S -> I\" = \"beta * S * (I/N) * timeStep\",   \"I -> R\" = d_gamma(rate = 1/3, shape = 2) ) parameters <- c(beta = 0.2, rate = 1/3, shape=2, N=1000)  initialValues <- c(S = 999, I = 1, I1 = 1, I2=0, R=0)  # --- Transition def for deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {        dS = - beta * S * I/N       # apply linear chain trick       dI1 = beta * S * I/N - rate*I1       dI2 = rate*I1 - rate*I2       dI =  dI1 + dI2       dR = rate*I2       list(c(dS, dI, dI1, dI2, dR))   }) }"},{"path":"/articles/denim_vs_deSolve.html","id":"run-simulation-with-denim","dir":"Articles","previous_headings":"Comparison between deSolve and denim","what":"Run simulation with denim","title":"denim vs deSolve","text":"","code":"denim_runtime <- bench::mark(   sim(transitions = transitions, initialValues = initialValues, parameters, simulationDuration = simulationDuration, timeStep = timestep),   iterations = 1 ) denim_runtime <- as.numeric(denim_runtime$total_time)  mod <- sim(transitions = transitions, initialValues = initialValues, parameters, simulationDuration = simulationDuration, timeStep = timestep) # --- show output head(mod[mod$Time %in% 1:simulationDuration,]) ##     Time        S        I          R ## 101    1 998.7825 1.169597 0.04786644 ## 201    2 998.5358 1.296591 0.16756473 ## 301    3 998.2665 1.399083 0.33440701 ## 401    4 997.9783 1.487980 0.53374794 ## 501    5 997.6732 1.569868 0.75697598 ## 601    6 997.3521 1.648745 0.99910771"},{"path":"/articles/denim_vs_deSolve.html","id":"run-simulation-with-desolve","dir":"Articles","previous_headings":"Comparison between deSolve and denim","what":"Run simulation with deSolve","title":"denim vs deSolve","text":"","code":"times <- seq(0, simulationDuration, timestep)  desolve_runtime <- bench::mark(   ode(y = initialValues, times = times, parms = parameters, func = transition_func),   iterations = 1 ) ## Warning: Some expressions had a GC in every iteration; so filtering is ## disabled. desolve_runtime <- as.numeric(desolve_runtime$total_time)  ode_mod <- ode(y = initialValues, times = times, parms = parameters, func = transition_func)  # --- show output ode_mod <- as.data.frame(ode_mod) head(ode_mod[ode_mod$time %in% 1:simulationDuration, c(\"time\", \"S\", \"I\", \"R\")]) ##     time        S        I         R ## 101    1 998.7824 1.169731 0.0479167 ## 201    2 998.5355 1.296752 0.1677463 ## 301    3 998.2660 1.399189 0.3347737 ## 401    4 997.9777 1.487967 0.5343309 ## 501    5 997.6725 1.569688 0.7577887 ## 601    6 997.3515 1.648357 1.0001499"},{"path":"/articles/denim_vs_deSolve.html","id":"execution-time-comparison","dir":"Articles","previous_headings":"Comparison between deSolve and denim","what":"Execution time comparison","title":"denim vs deSolve","text":"denim takes approximately 71.18 times long deSolve compute result given specifications . significant difference can attributed difference approaches: deSolve solves system ODEs denim iterates timestep updates population compartment approach denim allow flexibility types dwell time distributions, computation time scales exponentially timestep grows smaller.","code":""},{"path":"/articles/denim_vs_deSolve.html","id":"plot-the-result","dir":"Articles","previous_headings":"","what":"Plot the result","title":"denim vs deSolve","text":"","code":"# increase timestep before plotting mod <- mod[mod$Time %in% seq(0, simulationDuration, 0.2),] ode_mod <- ode_mod[ode_mod$time %in% seq(0, simulationDuration, 0.2),]"},{"path":[]},{"path":"/articles/denim_vs_deSolve.html","id":"implementation-using-desolve","dir":"Articles","previous_headings":"Comparison with SEIR model","what":"Implementation using deSolve","title":"denim vs deSolve","text":"","code":"library(deSolve) parameters <- c(gamma_rate_I = 1/4, shape_I=2,                 gamma_rate_R = 1/3, shape_R = 2,                 R0 = 3.5, N = 1e6)  initialValues <- c(S = 999999, E1 = 1,                    E2 = 0, E = 0, I1=0,                     I2=0, I=0, R=0                    )  # --- Transition def for deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {              tr = (1/gamma_rate_R)*shape_R              dS = - (R0/tr) * S * I/N       # apply linear chain trick       dE1 = (R0/tr) * S * I/N - gamma_rate_I*E1       dE2 = gamma_rate_I*E1 - gamma_rate_I*E2       dE = dE1 + dE2       dI1 = gamma_rate_I*E2 - gamma_rate_R*I1       dI2 = gamma_rate_R*I1 - gamma_rate_R*I2       dI =  dI1 + dI2        dR = gamma_rate_R*I2       list(c(dS, dE1, dE2, dE, dI1, dI2, dI, dR))   }) }  times <- seq(0, 210, 1)  ode_mod <- ode(y = initialValues, times = times, parms = parameters, func = transition_func)  # --- show output ode_mod <- as.data.frame(ode_mod)"},{"path":"/articles/denim_vs_deSolve.html","id":"implementation-using-denim","dir":"Articles","previous_headings":"Comparison with SEIR model","what":"Implementation using denim","title":"denim vs deSolve","text":"","code":"denim_model <- list(   \"S -> E\" = \"(R0/tr) * timeStep * S * (I/N)\", # formulate according that of uSEIR method   \"E -> I\" = d_gamma(rate = 1/4, shape = 2),   \"I -> R\" = d_gamma(rate = 1/3, shape = 2) )  initialValues <- c(S = 999999, E = 1, I= 0, R= 0) parameters <- c(R0 = 3.5,                  tr = 3*2, # compute mean recovery time, for gamma it's scale*shape                 N = 1e6, timeStepDur = 0.01)  mod <- sim(transitions = denim_model,                       initialValues = initialValues,                      parameters = parameters,                      simulationDuration = 210, timeStep = 0.01)  # denim_out[, c(\"S\",\"E\", \"I\", \"R\")] <- denim_out[, c(\"S\",\"E\", \"I\", \"R\")]/1e6 plot(mod)"},{"path":[]},{"path":"/articles/denim_vs_uSEIR.html","id":"useir-defined-in-python","dir":"Articles","previous_headings":"","what":"uSEIR defined in Python","title":"denim vs uSEIR","text":"Source code: https://github.com/jjgomezcadenas/useirn/blob/master/nb/uSEIR.ipynb","code":"library(reticulate) ## Warning: package 'reticulate' was built under R version 4.3.1 # use_python(\"/opt/anaconda3/envs/bnn/bin/python\", required = TRUE) use_condaenv(condaenv='bnn', required = TRUE) matplotlib <- import(\"matplotlib\") matplotlib$use(\"Agg\", force = TRUE) from scipy.stats import gamma import matplotlib import matplotlib.pyplot as plt matplotlib.use('Agg') from matplotlib.pyplot import imshow plt.rcParams[\"figure.figsize\"] = 10, 8 plt.rcParams[\"font.size\"     ] = 14 plt.rcParams['savefig.format'] = 'png' import numpy as np import pandas as pd import pyarrow as pa  def plot_useir(dfs, lbls, T = 'uSEIR', figsize=(10,10)):          fig = plt.figure(figsize=figsize)          ax=plt.subplot(1,2,1)     for i, df in enumerate(dfs):         df.head()         ls = f'S-{lbls[i]}'         lr = f'R-{lbls[i]}'         plt.plot(df.t, df.S, lw=2, label=ls)         plt.plot(df.t, df.R, lw=2, label=lr)      plt.xlabel('time (days)')     plt.ylabel('Fraction of population')     plt.legend()     plt.title(T)          ax=plt.subplot(1,2,2)     for i, df in enumerate(dfs):         le = f'E-{lbls[i]}'         li = f'I-{lbls[i]}'         plt.plot(df.t, df.E, lw=2, label=le)         plt.plot(df.t, df.I, lw=2, label=li)      plt.xlabel('time (days)')     plt.ylabel('Fraction of population')     plt.legend()          plt.title(T)     plt.tight_layout()     plt.show()  def solve_uSeir(ti_shape     = 5.5,                      ti_scale     = 1,                     tr_shape     = 6.5,                      tr_scale     = 1,                    R0           = 3.5):     \"\"\"     The pure python version only uses the gamma distribution and fine grain.     It's sole purpose is benchmarking the cython version     \"\"\"          # This function is similar to calcTransitionProb in denim     def compute_gamma_pde(t_shape, t_scale, eps, tol):         # compute dwell time steps unit         ne = int(gamma.ppf(tol, a=t_shape, scale=t_scale) / eps)         # transition rate per timestep          pdE = np.zeros(ne)         cd1 = 0         for i in np.arange(ne):             # equivalent to computing sum(pi_i) in denim             cd2    = gamma.cdf(i*eps, a=t_shape, scale=t_scale)             pdE[i] = cd2-cd1 # equivalent compute current transition prob in denim             cd1    = cd2                  # return values         # ne: equivalent of dwell time in time steps         # pdE: equivalent to p_i in denim paper         return ne, pdE      N       = 1e+6     Smin    = 1e-10      Emin    = 1e-10     nmax    = 21000 # max time steps     eps     = 0.01     tr = tr_shape*tr_scale     prob    = R0 / tr      pn      = prob * eps     tol     = 0.9999 # similar to the error tolerance in denim      nE, pdE = compute_gamma_pde(ti_shape, ti_scale, eps, tol)     nI, pdI = compute_gamma_pde(tr_shape, tr_scale, eps, tol)      print(f' Function solve_uSeir: time epsilon = {eps}')     print(f' statistical distribution is Gamma , ti = {ti_shape*ti_scale}, tr = {tr_shape*tr_scale}')     print(f' number of exposed compartments = {nE}, infected compartments = {nI}')     print(f' R0 = {R0}, prob = {prob}, pn = {pn}')           I   = np.zeros(nI)     E   = np.zeros(nE)     S    = 1 - 1/N     E[0] = 1 / N          R    = 0     sI   = 0      TT = []     SS = []     EE = []     II = []     RR = []     n    = 0          while True:                  # update R compartment           # I[0] here is equivalent to population that will move to R at t + 0 (i.e. current time step)          R += I[0]          # ----- Simulate for S-I first -----         end = nI - 1 # compute dwell time         # update population for I_k where I_k is the population that will move to R at time t + k (in time step)         for k in np.arange(end):             I[k] = I[k+1] + pdI[k] * E[0]              # pdI[k] * E[0] is just contact rate             # where I[k+1] is value computed from previous timestep (i.e. shift I[k+1] from old iteration to I[k] in current iteration)         I[end] = pdI[end] * E[0]                  #print(I)          # ----- Simulate I-E transition -----         end = nE - 1         for k in np.arange(end):             E[k] = E[k+1] + pn * pdE[k] * sI * S         E[end]   = pn * pdE[end] * sI * S          #print(E)                  # pn * sI * S equivalent to probs * epsilon * S * I/N         S  = S - pn * sI * S                  sI = np.sum(I)         sE = np.sum(E)                  #print(sI)         #print(sE)         TT.append(n * eps)         SS.append(S)         EE.append(sE)         II.append(sI)         RR.append(R)                  #print(f't = {n*eps} S = {S} E ={sE} I ={sI} R = {R}')         n+=1         if (sE < Smin and sI < Emin) or n > nmax:             break          df = pd.DataFrame(list(zip(TT, SS, EE, II, RR)),                 columns =['t', 'S', 'E', 'I', 'R'])           return df  # print(plt.gcf().canvas.get_supported_filetypes())"},{"path":"/articles/denim_vs_uSEIR.html","id":"run-simulation-using-pure-python-implementation","dir":"Articles","previous_headings":"uSEIR defined in Python","what":"Run simulation using pure Python implementation","title":"denim vs uSEIR","text":"Run time pure Python implementation ~ 59.9872","code":"import time from statistics import mean  runs = []  # --- Get runtime for 10 runs ---- # for i in range(10): #   start = time.time() #   df = solve_uSeir(ti_shape     = 2, #                      ti_scale     = 4, #                      tr_shape     = 2, #                      tr_scale     = 3, #                      R0           = 3.5) #   end = time.time() #   runs = runs + [end - start] #   mean(runs)    # plot_useir((df,), ('G',), T = 'uSEIR', figsize=(14,8)) # print(f'python solve_seir call: dr = {end-start}')"},{"path":"/articles/denim_vs_uSEIR.html","id":"run-simulation-using-cython-implementation","dir":"Articles","previous_headings":"uSEIR defined in Python","what":"Run simulation using cython implementation","title":"denim vs uSEIR","text":"Run time Cython implementation ~ 0.4140","code":"# import precompiled cython module import sys sys.path.insert(0, \"../supplements\") import useir import time  runs = [] # --- Get runtime for 10 runs ---- # for i in range(10): #   start = time.time() #   df = useir.csolve_uSeir(dist = \"gamma\", #                     ti_shape     = 2,   #                      ti_scale     = 4,  #                      tr_shape     = 2,   #                      tr_scale     = 3, #                      R0           = 3.5 #   ) #   end = time.time() #  #   runs = runs + [end - start] # mean(runs)  df = useir.csolve_uSeir(dist = \"gamma\",                     ti_shape     = 2,                        ti_scale     = 4,                       tr_shape     = 2,                        tr_scale     = 3,                      R0           = 3.5   ) ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 # convert to pyarrow table for easy conversion to R data.frames to_r_df = pa.Table.from_pandas(df)"},{"path":"/articles/denim_vs_uSEIR.html","id":"run-simulation-using-denim","dir":"Articles","previous_headings":"uSEIR defined in Python","what":"Run simulation using denim","title":"denim vs uSEIR","text":"Run time denim implementation ~ 1.002","code":"library(denim)  denim_model <- list(   \"S -> E\" = \"(R0/tr) * timeStepDur * S * (I/N)\", # formulate according that of uSEIR method   \"E -> I\" = d_gamma(scale = 4, shape = 2),   \"I -> R\" = d_gamma(scale = 3, shape = 2) )   initialValues <- c(S = 999999, E = 1, I= 0, R= 0) parameters <- c(R0 = 3.5,                  tr = 3*2, # compute mean recovery time, for gamma it's scale*shape                 N = 1e6, timeStepDur = 0.01)  # ---- Get runtimes of 10 runs ---- # runtimes <- sapply(1:10, #   function (i) { #     time <- system.time( #       sim(transitions = denim_model,  #                      initialValues = initialValues, #                      parameters = parameters, #                      simulationDuration = 210, timeStep = 0.01) #     ) #     return(time[[\"elapsed\"]]) #   }) #  # mean(runtimes)  # ---- Get output ---- denim_out <- sim(transitions = denim_model,                       initialValues = initialValues,                      parameters = parameters,                      simulationDuration = 210, timeStep = 0.01) ## Warning: package 'arrow' was built under R version 4.3.3 ##  ## Attaching package: 'arrow' ## The following object is masked from 'package:utils': ##  ##     timestamp"},{"path":"/articles/multinomial.html","id":"transition-to-multiple-states-in-denim","dir":"Articles","previous_headings":"","what":"1. Transition to multiple states in denim","title":"transition to multiple states","text":"Modelers may encounter many situations individuals can transition one compartment multiple others, SIRD model. 2 main approaches handle : Model transitions competing risks Model multinomial transition (outgoing population split fixed proportion transition new compartments). denim allows users model situations, requiring minimal change code base switch 2 methods modeling.","code":""},{"path":[]},{"path":"/articles/multinomial.html","id":"model-definition","dir":"Articles","previous_headings":"2. Multinomial in denim","what":"2.1. Model definition","title":"transition to multiple states","text":"specify proportion goes outgoing compartment, define transition using following syntax model definition: proportion * compartment ->  out_compartment = [transition] Note proportion proportion compartment end out_compartment equilibrium. Example: SIRD model 90% infected can recover remaining 10% die. \\[ \\begin{cases} dS = -\\beta S \\frac{}{N} \\\\ dIR_1 = 0.9 *\\beta S \\frac{}{N} -\\frac{1}{3}IR_1 \\\\ dIR_2 = \\frac{1}{3}IR_1 - \\frac{1}{3}IR_2 \\\\ = 0.1*\\beta S \\frac{}{N} - 0.1*ID \\\\ dR = \\frac{1}{3}IR_2 \\\\ dD = 0.1*ID \\end{cases} \\]","code":"transitions <- denim_dsl({   S -> I = beta * S * (I / N)    0.9 * I -> R = d_gamma(1/3, 2)   0.1 * I -> D = d_exponential(0.1) })"},{"path":"/articles/multinomial.html","id":"proportion-normalization","dir":"Articles","previous_headings":"2. Multinomial in denim > 2.1. Model definition","what":"Proportion normalization","title":"transition to multiple states","text":"denim automatically normalize proportions don’t sum 1. Example 2: following model definition equivalent one Example 1","code":"transitions <- denim_dsl({   S -> I = beta * S * (I / N)   36 * I -> R = d_gamma(1/3, 2)   4 * I -> D = d_exponential(0.1) })"},{"path":"/articles/multinomial.html","id":"example-model","dir":"Articles","previous_headings":"2. Multinomial in denim","what":"2.2. Example model","title":"transition to multiple states","text":"demonstrate implementation multinomial denim, provide equivalent model implemented deSolve compare output 2 implementations.","code":""},{"path":"/articles/multinomial.html","id":"model-definition-in-denim","dir":"Articles","previous_headings":"2. Multinomial in denim > 2.2. Example model","what":"Model definition in denim","title":"transition to multiple states","text":"","code":"# model in denim transitions <- denim_dsl({   S -> I = beta * S * (I / N)    0.9 * I -> R = d_gamma(1/3, 2)   0.1 * I -> D = d_exponential(0.1) })  denimInitialValues <- c(   S = 999,    I = 1,    R = 0,   D = 0 )"},{"path":"/articles/multinomial.html","id":"equivalent-model-definition-in-desolve","dir":"Articles","previous_headings":"2. Multinomial in denim > 2.2. Example model","what":"Equivalent model definition in deSolve","title":"transition to multiple states","text":"","code":"# model in deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {        dS = - beta * S * (IR1 + IR2 + ID)/N       # apply linear chain trick for I -> R transition       # 0.9 * to specify prop of I that goes to I->R transition       dIR1 = 0.9 * beta * S * (IR1 + IR2 + ID)/N - rate*IR1       dIR2 = rate*IR1 - rate*IR2       dR = rate*IR2               # handle I -> D transition       # 0.1 * to specify prop of I that goes to I->D transition       dID = 0.1 * beta * S * (IR1 + IR2 + ID)/N - exp_rate*ID       dD = exp_rate*ID       list(c(dS, dIR1, dIR2, dID, dR, dD))   }) }  desolveInitialValues <- c(   S = 999,    # note that internally, denim also allocate initial value based on specified proportion   IR1 = 0.9,   IR2 = 0,   ID = 0.1,    R = 0,   D = 0 )"},{"path":"/articles/multinomial.html","id":"run-simulation-and-compare","dir":"Articles","previous_headings":"2. Multinomial in denim > 2.2. Example model","what":"Run simulation and compare","title":"transition to multiple states","text":"Output Comparison","code":"parameters <- c(   beta = 0.2,   N = 1000,   rate = 1/3,   exp_rate = 0.1 )  simulationDuration <- 200 timeStep <- 0.05 # --- run denim model ----  mod <- sim(transitions = transitions,             initialValues = denimInitialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep)  # run deSolve model times <- seq(0, simulationDuration) ode_mod <- ode(y = desolveInitialValues, times = times, parms = parameters, func = transition_func)  ode_mod <- as.data.frame(ode_mod) ode_mod$I<- rowSums(ode_mod[, c(\"IR1\", \"IR2\", \"ID\")])"},{"path":[]},{"path":"/articles/multinomial.html","id":"model-definition-1","dir":"Articles","previous_headings":"3. Competing risks in denim","what":"3.1. Model definition","title":"transition to multiple states","text":"multiple transitions one compartment proportions specified, denim automatically treat transitions competing risks. Example: following model definition treat ->R ->D competing risks.","code":"transitions <- denim_dsl({   S -> I = beta * S * (I / N)   I -> R = d_gamma(rate = 1/3, shape = 2)   I -> D = d_gamma(rate = 1/4, shape = 2) })"},{"path":"/articles/multinomial.html","id":"example-model-1","dir":"Articles","previous_headings":"3. Competing risks in denim","what":"3.2. Example model","title":"transition to multiple states","text":"demonstrate implementation competing risks denim, provide equivalent model implemented deSolve compare output 2 implementations.","code":""},{"path":"/articles/multinomial.html","id":"model-definition-in-denim-1","dir":"Articles","previous_headings":"3. Competing risks in denim > 3.2. Example model","what":"Model definition in denim","title":"transition to multiple states","text":"","code":"transitions <- denim_dsl({   S -> I = beta * S * (I / N)   I -> R = d_gamma(rate = 1/3, shape = 2)   I -> D = d_gamma(rate = 1/4, shape = 2) })  denimInitialValues <- c(   S = 950,    I = 50,    R = 0,    D = 0 )"},{"path":"/articles/multinomial.html","id":"equivalent-model-definition-in-desolve-1","dir":"Articles","previous_headings":"3. Competing risks in denim > 3.2. Example model","what":"Equivalent model definition in deSolve","title":"transition to multiple states","text":"","code":"transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {     dS = - beta * S * (I1 + I2 + IR + ID)/N      dI1 = beta * S * (I1 + I2 + IR + ID)/N - (rate+d_rate)*I1      dIR = rate*I1 - (d_rate + rate)*IR     dID = d_rate*I1 - (d_rate + rate)*ID      dI2 = d_rate*IR + rate*ID - (d_rate + rate)*I2      dR = rate*IR + rate*I2     dD = d_rate*ID + d_rate*I2      list(c(dS, dI1, dIR, dID, dI2, dR, dD))   }) }  desolveInitialValues <- c(   S = 950,    I1 = 50,   IR = 0,   ID = 0,   I2 = 0,   R = 0,   D = 0 )"},{"path":"/articles/multinomial.html","id":"run-simulation-and-compare-1","dir":"Articles","previous_headings":"3. Competing risks in denim > 3.2. Example model","what":"Run simulation and compare","title":"transition to multiple states","text":"","code":"parameters <- c(   beta = 0.2,   N = 1000,   rate = 1/3,   d_rate = 1/4 )  simulationDuration <- 50 timeStep <- 0.05 # run denim model mod <- sim(transitions = transitions,             initialValues = denimInitialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep)  # run deSolve model times <- seq(0, simulationDuration) ode_mod <- ode(y = desolveInitialValues, times = times, parms = parameters, func = transition_func)  ode_mod <- as.data.frame(ode_mod) ode_mod$I <- rowSums(ode_mod[,c(\"I1\", \"ID\", \"IR\", \"I2\")])"},{"path":"/articles/nonparametric.html","id":"non-parametric-vs-parametric","dir":"Articles","previous_headings":"","what":"Non-parametric vs parametric","title":"nonparametric distribution","text":"denim, users 2 options define dwell-time distribution: parametric distribution: using d_*() functions. non-parametric distribution: using nonparametric() function user must provide histogram distribution bin-width matches time step.","code":""},{"path":"/articles/nonparametric.html","id":"example-1","dir":"Articles","previous_headings":"Non-parametric vs parametric","what":"Example 1","title":"nonparametric distribution","text":"demonstrate difference 2 approaches, can try modeling SIR model Weibull distributed infectious period using nonparametric() d_weibull(). Model definition using d_weibull() Model parameters must defined : beta, N, r_scale, r_shape Model definition using nonparametric() Model parameters must defined : beta, N, dwelltime_dist (discrete dwell time distribution) Run model run models following model settings Running model d_weibull() straight forward  However, run model using nonparametric(), first need compute discrete dwell time distribution (dwelltime_dist). Since parametric distributions asymptotic 1, set maximal dwell time time point cumulative probability sufficiently close 1 (.e. threshold 1 - error_tolerance). helper function compute discrete dwell time distribution distribution function R provided . can run model followed","code":"sir_parametric <- denim_dsl({   S -> I = beta * (I/N) * S   I -> R = d_weibull(scale = r_scale, shape = r_shape) }) sir_nonparametric <- denim_dsl({   S -> I = beta * (I/N) * S   I -> R = nonparametric(dwelltime_dist) }) # parameters mod_params <- list(   beta = 0.4,   N = 1000,   r_scale = 4,   r_shape = 3 ) # initial population init_vals <- c(S = 950, I = 50, R = 0) # simulation duration and timestep sim_duration <- 30 timestep <- 0.05 parametric_mod <- sim(sir_parametric,     initialValues = init_vals,     parameters = mod_params,     simulationDuration = sim_duration,     timeStep = timestep)   plot(parametric_mod, ylim = c(0, 1000)) # Compute discrete distribution of dwell-tinme # dist_func - R distribution function for dwell time (pexp, pgamma, etc.) # ... - parameters for dist_func compute_dist <- function(dist_func,..., timestep=0.05, error_tolerance=0.0001){   maxtime <- timestep   prev_prob <- 0   prob_dist <- numeric()      while(TRUE){      # get current cumulative prob and check whether it is sufficiently close to 1      temp_prob <-  ifelse(        dist_func(maxtime, ...) < (1 - error_tolerance),         dist_func(maxtime, ...),         1);       # get f(t)      curr_prob <- temp_prob - prev_prob      prob_dist <- c(prob_dist, curr_prob)            prev_prob <- temp_prob      maxtime <- maxtime + timestep            if(temp_prob == 1){        break      }   }      prob_dist } # Compute the discrete distribution dwelltime_dist <- compute_dist(pweibull,                                 scale = mod_params$r_scale, shape = mod_params$r_shape,                                timestep = timestep)  # Compute the discrete distribution nonparametric_mod <- sim(sir_nonparametric,     initialValues = init_vals,     parameters = list(       beta = mod_params$beta,       N = mod_params$N,       dwelltime_dist = dwelltime_dist     ),     simulationDuration = sim_duration,     timeStep = timestep)  plot(nonparametric_mod, ylim = c(0, 1000))"},{"path":"/articles/nonparametric.html","id":"example-2","dir":"Articles","previous_headings":"Non-parametric vs parametric","what":"Example 2","title":"nonparametric distribution","text":"using nonparametric(), can run model dwell time distribution shape Consider following multimodal distribution.  can also run sir_nonparametric model last example dwell time distribution","code":"timestep <- 0.05 plot(seq(0, by = 0.05, length.out = length(multimodal_dist)),       multimodal_dist,       type = \"l\", col = \"#374F77\", lty = 1, lwd = 3,      xlab = \"Length of stay (days)\", ylab = \"\", yaxt = 'n') # model parameter parameters <- list(beta = 0.4, N = 1000,                    dwelltime_dist = multimodal_dist) # initial population init_vals <- c(S = 950, I = 50, R = 0) # simulation duration and timestep sim_duration <- 30 timestep <- 0.05  # Run the model with multimodel distribution nonparametric_mod <- sim(   sir_nonparametric,   initialValues = init_vals,   parameters = parameters,   simulationDuration = sim_duration,   timeStep = timestep)  plot(nonparametric_mod, ylim = c(0, 1000))"},{"path":"/articles/web_only/denim.html","id":"simple-sir-model-with-gamma-distributed-lengths-of-stay","dir":"Articles > Web_only","previous_headings":"","what":"1. Simple SIR model with gamma distributed lengths of stay","title":"denim: deterministic discrete-time model with memory","text":"SIR model uses 3 compartments: S (susceptible), (infected), R (recovered) describe clinical status individuals. use simple form SIR model demonstrate define distribution lengths stay distribution. model equations : \\[S_{t+1} - S_{t} = -\\lambda S_{t} = -\\frac{\\beta I_{t}}{N}S_{t}\\] \\[I_{t+1} - I_{t} = \\frac{\\beta I_{t}}{N}S_{t} - \\gamma I_{t}\\] \\[R_{t+1} - R_{t} = \\gamma I_{t}\\] \\(N\\): total population size, \\(N = S + + R\\) \\(\\beta\\): product contact rates transmission probability; usually define \\(\\lambda =\\frac{\\beta I_{t}}{N}\\) force infection \\(\\gamma\\): recovery rate Usually solve model easier make assumption recovery rate \\(\\gamma\\) constant, leads exponentially distributed length stay .e individuals recover 1 day infected.  realistic length stay distribution can look like , patients recovered 4 days. defined using gamma distribution shape = 3 scale = 2.  model now look like : Model specification Model transition two transitions S -> -> R case. transitions specified list follow format \"transition\" = equation, equation defined one functions waiting time distribution. Initial state Use vector define compartments assigned names initial values format compartment_name = initial_value: Model parameters use math expression, symbols except compartment names parameters, defined constant values. two constant parameters example: beta N: Model application Time step specification run model 30 days give output 0.01 daily intervals. default interval (time step) 1 declared explicitly.","code":"transitions <- list(   \"S -> I\" = \"beta * S * I / N\",   \"I -> R\" = d_gamma(3, 2) ) initialValues <- c(   S = 999,    I = 1,    R = 0 ) parameters <- c(   beta = 0.012,   N = 1000 ) simulationDuration <- 30 timeStep <- 0.01 mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) head(mod) #>   Time        S        I            R #> 1 0.00 999.0000 1.000000 0.000000e+00 #> 2 0.01 998.9880 1.011982 5.543225e-06 #> 3 0.02 998.9759 1.024097 2.219016e-05 #> 4 0.03 998.9636 1.036346 5.000038e-05 #> 5 0.04 998.9512 1.048730 8.903457e-05 #> 6 0.05 998.9386 1.061252 1.393545e-04 plot(mod)"},{"path":"/articles/web_only/denim.html","id":"how-the-algorithm-work","dir":"Articles > Web_only","previous_headings":"","what":"2. How the algorithm work?","title":"denim: deterministic discrete-time model with memory","text":"SIR model, infected individuals presented single compartment recovery rate \\(\\gamma\\). want recovery rate individuals infected 1 day differ recovery rate 2-day infected patients. rather using one compartment infected (), define multiple infected sub-compartments. number sub-compartments depends maximum day expect infected individuals recovered. example, expect disease maximum 4 days infection, end 4 sub-compartments. sub-compartment recovery rate \\(\\gamma_{1}\\), \\(\\gamma_{2}\\), \\(\\gamma_{3}\\), \\(\\gamma_{4}\\). day 4 certain patient recover (assume disease maximum 4 days infection), \\(\\gamma_{4} = 1\\). Let \\(R_1 + R_2 + R_3 + R_4 = \\Sigma R\\). \\(\\frac{R_1}{\\Sigma R} = p_1\\), \\(\\frac{R_2}{\\Sigma R} = p_2\\), \\(\\frac{R_3}{\\Sigma R} = p_3\\), \\(\\frac{R_4}{\\Sigma R} = p_4\\). mission estimate \\(\\gamma_{1}\\), \\(\\gamma_{2}\\), \\(\\gamma_{3}\\) obtain \\(p_1\\), \\(p_2\\), \\(p_3\\), \\(p_4\\) fit pre-defined distribution equilibrium state. can obtained setting: \\[\\gamma_{} = \\frac{p_i}{1 - \\sum_{j=1}^{-1}p_j}\\] given length stay distribution, identify maximum length stay using cumulative distribution function. cumulative distribution function asymptotic 1 never equal 1, need set value acceptable rounded 1. want cumulative probability 0.999 rounded 1, set error tolerance threshold 1 - 0.999 = 0.001 (specified argument errorTolerance = 0.001). time cumulative probability = 0.999 set maximum length stay compartment. Default errorTolerance denim set 0.001.","code":""},{"path":"/articles/web_only/denim.html","id":"waiting-time-distribution","dir":"Articles > Web_only","previous_headings":"","what":"3. Waiting time distribution","title":"denim: deterministic discrete-time model with memory","text":"Current available distribution package including: d_exponential(rate): Discrete exponential distribution parameter rate d_gamma(scale, shape): Discrete gamma distribution parameters scale shape d_weibull(scale, shape): Discrete Weibull distribution parameters scale shape d_lognormal(mu, sigma): Discrete log-normal distribution parameters mu sigma can define type transitions : Mathematical expression: Transition defined string value \"beta * S * / N\" converted mathematical expression. need define parameters compartment names parameters argument Constant: Transition defined numerical value 1, 2 converted constant. define number individuals moving time step. transprob(x): Every time step fixed percentage left compartment transit right compartment, also convenient way define \\(R_t - R_{t-1} = \\gamma \\) can input \"-> R\" = transprob(gamma) nonparametric(waitingTimes...): vector values, numbers, percentages, density length stay based real data, denim convert distribution multinomial(probabilities): convenient way define several probabilities compartment transit many compartments, may may time step. example, \"V -> VA, VS, VH\" = multinomial(0.6, 0.3, 0.1) means 60% V become VA, 30% become VS 10% become VH. continue define length stay distribution transitions e.g \"V -> VA\" = d_gamma(3, 2), probabilities defined multinomial() percentage left compartment transit time step, percentage individuals move VA equilibrium state. define length stay distribution, \"V -> VA, VS, VH\" = multinomial(0.6, 0.3, 0.1) percentage V transit right compartments per time step similar transprob() function. See detailed explanations Multiple transitions compartment section.","code":""},{"path":"/articles/web_only/denim.html","id":"multiple-transitions-from-a-compartment","dir":"Articles > Web_only","previous_headings":"","what":"4. Multiple transitions from a compartment","title":"denim: deterministic discrete-time model with memory","text":"many ways define type transition two transitions compartment. Consider example: two scenarios example: Susceptible individuals can infected vaccinated. assumption infected first (S -> ), rest infected get vaccinated (S -> V). Infected individuals can recover die. mortality probability known, can implement model, example defining 0.9 * -> R (90% individuals recover) 0.1 * -> D (10% die). , ensure mortality probability 10%, also define length stay individuals infected state recover die follows gamma log-normal distribution, respectively. can define model example follows:  Tips: Instead writing: can also use multinomial(), define length stay distribution obtain result:","code":"transitions <- list(   \"S -> I\" = \"beta * S * I / N\",   \"S -> V\" = 7,   \"0.9 * I -> R\" = d_gamma(3, 2),   \"0.1 * I -> D\" = d_lognormal(2, 0.5) )  initialValues <- c(   S = 999,    I = 1,    R = 0,   V = 0,   D = 0 )  parameters <- c(   beta = 0.12,   N = 1000 )  simulationDuration <- 10 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) plot(mod) \"0.9 * I -> R\" = d_gamma(3, 2), \"0.1 * I -> D\" = d_lognormal(2, 0.5) \"I -> R, D\" = multinomial(0.9, 0.1), \"I -> R\" = d_gamma(3, 2), \"I -> D\" = d_lognormal(2, 0.5)"},{"path":"/articles/web_only/denim.html","id":"another-example","dir":"Articles > Web_only","previous_headings":"","what":"5. Another example","title":"denim: deterministic discrete-time model with memory","text":"","code":"transitions <- list(   \"S -> I\" = \"beta * S * (I + IV) / N\",   \"S -> V\" = 2,   \"0.1 * I -> D\" = d_lognormal(2, 0.5),   \"0.9 * I -> R\" = d_gamma(3, 2),   \"V -> IV\" = \"0.1 * beta * V * (I + IV) / N\",   \"IV -> R\" = d_exponential(2) )  initialValues <- c(   S = 999,    I = 1,    R = 0,   V = 0,   IV = 0,   D = 0 )  parameters <- c(   beta = 0.12,   N = 1000 )  simulationDuration <- 10 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) plot(mod)"},{"path":"/articles/web_only/denim_vs_deSolve.html","id":"comparison-between-desolve-and-denim","dir":"Articles > Web_only","previous_headings":"","what":"Comparison between deSolve and denim","title":"denim vs deSolve","text":"Using deSolve, can replicate Erlang distribution exponential distribution testing","code":"library(denim) library(deSolve) ## Warning: package 'deSolve' was built under R version 4.3.1 # --- Transition def for denim transitions <- list(   \"S -> I\" = d_exponential(0.2),   \"I -> R\" = d_gamma(3, 2) ) parameters <- c(rate = 0.2, scale = 3, shape=2)  initialValues <- c(S = 999, I = 1, I1 = 1, I2=0, R=0)  # --- Transition def for deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {       gamma_rate = 1/scale       dS = -rate*S       # apply linear chain trick       dI1 = rate*S - gamma_rate*I1       dI2 = gamma_rate*I1 - gamma_rate*I2       dI =  dI1 + dI2       dR = gamma_rate*I2       list(c(dS, dI, dI1, dI2, dR))   }) }  # --- Timestep definition simulationDuration <- 20  timestep <- 0.001 # small timestep required for comparison"},{"path":"/articles/web_only/denim_vs_deSolve.html","id":"run-simulation-with-denim","dir":"Articles > Web_only","previous_headings":"Comparison between deSolve and denim","what":"Run simulation with denim","title":"denim vs deSolve","text":"","code":"denim_start <- Sys.time() mod <- sim(transitions = transitions, initialValues = initialValues, parameters, simulationDuration = simulationDuration, timeStep = timestep) denim_end <- Sys.time()  # --- show output head(mod[mod$Time %in% 1:simulationDuration,]) ##      Time        S        I          R ## 1001    1 817.9120 179.0627   3.025308 ## 2001    2 669.6497 310.8811  19.469173 ## 3001    3 548.2628 398.4336  53.303539 ## 4001    4 448.8796 448.0932 103.027204 ## 5001    5 367.5116 467.6504 164.838060 ## 6001    6 300.8930 464.7307 234.376244"},{"path":"/articles/web_only/denim_vs_deSolve.html","id":"run-simulation-with-desolve","dir":"Articles > Web_only","previous_headings":"Comparison between deSolve and denim","what":"Run simulation with deSolve","title":"denim vs deSolve","text":"","code":"times <- seq(0, simulationDuration, timestep)  desolve_start <- Sys.time() ode_mod <- ode(y = initialValues, times = times, parms = parameters, func = transition_func) desolve_end <- Sys.time()  # --- show output ode_mod <- as.data.frame(ode_mod) head(ode_mod[ode_mod$time %in% 1:simulationDuration, c(\"time\", \"S\", \"I\", \"R\")]) ##      time        S        I          R ## 1001    1 817.9120 179.0585   3.029466 ## 2001    2 669.6497 310.8686  19.481654 ## 3001    3 548.2628 398.4125  53.324630 ## 4001    4 448.8796 448.0650 103.055392 ## 5001    5 367.5116 467.6172 164.871207 ## 6001    6 300.8930 464.6948 234.412204"},{"path":"/articles/web_only/denim_vs_deSolve.html","id":"execution-time-comparison","dir":"Articles > Web_only","previous_headings":"Comparison between deSolve and denim","what":"Execution time comparison","title":"denim vs deSolve","text":"denim takes approximately 101.74 times long deSolve compute result given specifications . significant difference can attributed difference approaches: deSolve solves system ODEs denim iterates timestep updates population compartment approach denim allow flexibility types dwell time distributions, computation time scales timestep grows smaller (O(n) time complexity).","code":""},{"path":"/articles/web_only/denim_vs_deSolve.html","id":"plot-the-result","dir":"Articles > Web_only","previous_headings":"","what":"Plot the result","title":"denim vs deSolve","text":"","code":"# increase timestep before plotting mod <- mod[mod$Time %in% seq(0, simulationDuration, 0.2),] ode_mod <- ode_mod[ode_mod$time %in% seq(0, simulationDuration, 0.2),] # ---- Plot S compartment plot(x = mod$Time, y = mod$S,xlab = \"Time\", ylab = \"Count\", main=\"S compartment\",      col = \"#4876ff\", type=\"l\", lwd=3) lines(ode_mod$time, ode_mod$S, lwd=3, lty=3) legend(x = 15, y = 900,legend=c(\"denim\", \"deSolve\"), col = c(\"#4876ff\", \"black\"), lty=c(1,3)) # ---- Plot I compartment plot(x = mod$Time, y = mod$I, xlab = \"Time\", ylab = \"Count\", main=\"I compartment\",       col = \"#4876ff\", type=\"l\", lwd=2) lines(ode_mod$time, ode_mod$I, lwd=3, lty=3) legend(x = 15, y = 350,legend=c(\"denim\", \"deSolve\"), col = c(\"#4876ff\", \"black\"), lty=c(1,3)) # ---- Plot R compartment plot(x = mod$Time, y = mod$R, xlab = \"Time\", ylab = \"Count\", main=\"R compartment\",      col = \"#4876ff\", type=\"l\", lwd=2) lines(ode_mod$time, ode_mod$R, lwd=3, lty=3) legend(x = 15, y = 300,legend=c(\"denim\", \"deSolve\"), col = c(\"#4876ff\", \"black\"), lty=c(1,3))"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Thinh Ong. Author, copyright holder. Anh Phan. Author, maintainer. Marc Choisy. Author. Niels Lohman. Contributor. Bjoern Hoehrmann. Contributor. Florian Loitsch. Contributor. Ingo Berg. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ong T, Phan , Choisy M (2025). denim: Generate Simulate Deterministic Discrete-Time Compartmental Models. https://drthinhong.com/denim/, https://github.com/thinhong/denim.","code":"@Manual{,   title = {denim: Generate and Simulate Deterministic Discrete-Time Compartmental Models},   author = {Thinh Ong and Anh Phan and Marc Choisy},   year = {2025},   note = {https://drthinhong.com/denim/, https://github.com/thinhong/denim}, }"},{"path":"/index.html","id":"denim-","dir":"","previous_headings":"","what":"Generate and Simulate Deterministic Discrete-Time Compartmental Models","title":"Generate and Simulate Deterministic Discrete-Time Compartmental Models","text":"R package building simulating deterministic discrete-time compartmental models memory.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Generate and Simulate Deterministic Discrete-Time Compartmental Models","text":"can install denim CRAN : install development version denim GitHub :","code":"install.packages(\"denim\") # install.packages(\"devtools\") devtools::install_github(\"thinhong/denim\")"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Generate and Simulate Deterministic Discrete-Time Compartmental Models","text":"basic example illustrate specification simple SIR model, contains three compartments susceptible (S), infected () recovered (R). recovery probabilities infected individuals gamma distributed example: output data frame 4 columns: Time, S, R can plot output :","code":"library(denim)  transitions <- denim_dsl({   S -> I = beta * S * I / N   I -> R = d_gamma(rate = 1/3, shape = 2) })  parameters <- c(   beta = 1.2,   N = 1000 )  initialValues <- c(   S = 999,    I = 1,    R = 0 )  simulationDuration <- 20 timeStep <- 0.01  mod <- sim(transitions = transitions, initialValues = initialValues,             parameters = parameters, simulationDuration = simulationDuration,             timeStep = timeStep) head(mod) #>   Time        S        I            R #> 1 0.00 999.0000 1.000000 0.000000e+00 #> 2 0.01 998.9880 1.011982 5.543225e-06 #> 3 0.02 998.9759 1.024097 2.219016e-05 #> 4 0.03 998.9636 1.036346 5.000038e-05 #> 5 0.04 998.9512 1.048730 8.903457e-05 #> 6 0.05 998.9386 1.061252 1.393545e-04 plot(mod, ylim = c(1, 1000))"},{"path":"/reference/constant.html","id":null,"dir":"Reference","previous_headings":"","what":"Fixed transition — constant","title":"Fixed transition — constant","text":"Define fixed number individuals left compartment transit right compartment every time step","code":""},{"path":"/reference/constant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fixed transition — constant","text":"","code":"constant(x)"},{"path":"/reference/constant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fixed transition — constant","text":"x number individuals move one compartment another","code":""},{"path":"/reference/constant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fixed transition — constant","text":"Distribution object simulator","code":""},{"path":"/reference/constant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fixed transition — constant","text":"","code":"transitions <- list(\"S->I\" = constant(10))"},{"path":"/reference/d_exponential.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete exponential distribution — d_exponential","title":"Discrete exponential distribution — d_exponential","text":"Discrete exponential distribution","code":""},{"path":"/reference/d_exponential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete exponential distribution — d_exponential","text":"","code":"d_exponential(rate, dist_init = FALSE)"},{"path":"/reference/d_exponential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete exponential distribution — d_exponential","text":"rate rate parameter exponential distribution dist_init whether distribute initial value across subcompartments following distribution. (default FALSE, meaning init value always first compartment)","code":""},{"path":"/reference/d_exponential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete exponential distribution — d_exponential","text":"Distribution object simulator","code":""},{"path":"/reference/d_exponential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete exponential distribution — d_exponential","text":"","code":"transitions <- list(\"I -> D\" = d_exponential(0.3)) transitions <- denim_dsl({I -> D = d_exponential(0.3)})"},{"path":"/reference/d_gamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete gamma distribution — d_gamma","title":"Discrete gamma distribution — d_gamma","text":"Discrete gamma distribution","code":""},{"path":"/reference/d_gamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete gamma distribution — d_gamma","text":"","code":"d_gamma(rate, shape, dist_init = FALSE)"},{"path":"/reference/d_gamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete gamma distribution — d_gamma","text":"rate rate parameter gamma distribution shape shape parameter gamma distribution dist_init whether distribute initial value across subcompartments following distribution.","code":""},{"path":"/reference/d_gamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete gamma distribution — d_gamma","text":"Distribution object simulator","code":""},{"path":"/reference/d_gamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete gamma distribution — d_gamma","text":"","code":"transitions <- list(\"S -> I\" = d_gamma(rate = 1, shape = 5)) transitions_dsl <- denim_dsl({S -> I = d_gamma(rate = 1, shape = 5)}) # define model parameters as distributional parameters transitions_dsl <- denim_dsl({S -> I = d_gamma(rate = i_rate, shape = i_shape)})"},{"path":"/reference/d_lognormal.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete log-normal distribution — d_lognormal","title":"Discrete log-normal distribution — d_lognormal","text":"Discrete log-normal distribution","code":""},{"path":"/reference/d_lognormal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete log-normal distribution — d_lognormal","text":"","code":"d_lognormal(mu, sigma, dist_init = FALSE)"},{"path":"/reference/d_lognormal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete log-normal distribution — d_lognormal","text":"mu location parameter ln mean sigma scale parameter ln standard deviation dist_init whether distribute initial value across subcompartments following distribution. (default FALSE, meaning init value always first compartment)","code":""},{"path":"/reference/d_lognormal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete log-normal distribution — d_lognormal","text":"Distribution object simulator","code":""},{"path":"/reference/d_lognormal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete log-normal distribution — d_lognormal","text":"","code":"transitions <- list(\"I -> D\" = d_lognormal(3, 0.6)) transitions <- denim_dsl({I -> D = d_lognormal(3, 0.6)})"},{"path":"/reference/d_weibull.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete Weibull distribution — d_weibull","title":"Discrete Weibull distribution — d_weibull","text":"Discrete Weibull distribution","code":""},{"path":"/reference/d_weibull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete Weibull distribution — d_weibull","text":"","code":"d_weibull(scale, shape, dist_init = FALSE)"},{"path":"/reference/d_weibull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete Weibull distribution — d_weibull","text":"scale scale parameter Weibull distribution shape shape parameter Weibull distribution dist_init whether distribute initial value across subcompartments following distribution. (default FALSE, meaning init value always first compartment)","code":""},{"path":"/reference/d_weibull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete Weibull distribution — d_weibull","text":"Distribution object simulator","code":""},{"path":"/reference/d_weibull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete Weibull distribution — d_weibull","text":"","code":"transitions <- list(\"I -> D\" = d_weibull(0.6, 2)) transitions <- denim_dsl({ I -> D = d_weibull(0.6, 2) })"},{"path":"/reference/denim-package.html","id":null,"dir":"Reference","previous_headings":"","what":"denim — denim-package","title":"denim — denim-package","text":"Simulate deterministic discrete time model","code":""},{"path":"/reference/denim-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"denim — denim-package","text":"Imports","code":""},{"path":[]},{"path":"/reference/denim-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"denim — denim-package","text":"Maintainer: Anh Phan anhptq@oucru.org (ORCID) Authors: Thinh Ong thinhop@oucru.org (ORCID) [copyright holder] Marc Choisy mchoisy@oucru.org (ORCID) contributors: Niels Lohman [contributor] Bjoern Hoehrmann bjoern@hoehrmann.de [contributor] Florian Loitsch [contributor] Ingo Berg [contributor]","code":""},{"path":"/reference/denim_dsl.html","id":null,"dir":"Reference","previous_headings":"","what":"Define transitions using denim's domain-specific language (DSL) — denim_dsl","title":"Define transitions using denim's domain-specific language (DSL) — denim_dsl","text":"function parses model transitions defined denim's DSL syntax","code":""},{"path":"/reference/denim_dsl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define transitions using denim's domain-specific language (DSL) — denim_dsl","text":"","code":"denim_dsl(x)"},{"path":"/reference/denim_dsl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define transitions using denim's domain-specific language (DSL) — denim_dsl","text":"x expression written denim's DSL syntax. line transition written format compartment -> out_compartment = expression expression can either math expression one denim's built-dwell time distribution function","code":""},{"path":"/reference/denim_dsl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define transitions using denim's domain-specific language (DSL) — denim_dsl","text":"denim_transition object","code":""},{"path":"/reference/denim_dsl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define transitions using denim's domain-specific language (DSL) — denim_dsl","text":"","code":"transitions <- denim_dsl({   S -> I = beta * (I/N) * S    I -> R = d_gamma(rate = 1/4, shape = 3) })"},{"path":"/reference/mathexpr.html","id":null,"dir":"Reference","previous_headings":"","what":"Mathematical expression — mathexpr","title":"Mathematical expression — mathexpr","text":"Mathematical expression","code":""},{"path":"/reference/mathexpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mathematical expression — mathexpr","text":"","code":"mathexpr(expr)"},{"path":"/reference/mathexpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mathematical expression — mathexpr","text":"expr User defined mathematial expression. expression processed muparser library offers wide variety operators. Visit muparser website (https://beltoforion.de/en/muparser/features.php) see full list available operators.","code":""},{"path":"/reference/mathexpr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mathematical expression — mathexpr","text":"Distribution object simulator","code":""},{"path":"/reference/mathexpr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mathematical expression — mathexpr","text":"","code":"transitions <- list(\"S->I\"=\"beta*S/N\") transitions <- denim_dsl({S->I=beta*S/N}) # definition for parameters in the expression required params <- c(N = 1000, beta = 0.3)"},{"path":"/reference/multinomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Multinomial — multinomial","title":"Multinomial — multinomial","text":"Define set probabilities transition one compartment multiple compartments   equal ","code":"\"I -> R\" = d_gamma(1/3, 2), \"I -> D\" = d_lognormal(2, 0.5) \"0.5 * I -> R\" = d_gamma(1/3, 2), \"0.5 * I -> D\" = d_lognormal(2, 0.5)"},{"path":"/reference/multinomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multinomial — multinomial","text":"","code":"multinomial(...)"},{"path":"/reference/multinomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multinomial — multinomial","text":"... vector probabilities. Vector automatically rescaled sum 1.","code":""},{"path":"/reference/multinomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multinomial — multinomial","text":"Distribution object simulator","code":""},{"path":"/reference/nonparametric.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric distribution — nonparametric","title":"Nonparametric distribution — nonparametric","text":"Convert vector frequencies, percentages... distribution","code":""},{"path":"/reference/nonparametric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric distribution — nonparametric","text":"","code":"nonparametric(x, dist_init = FALSE)"},{"path":"/reference/nonparametric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric distribution — nonparametric","text":"x vector values dist_init whether distribute initial value across subcompartments following distribution. (default FALSE, meaning init value always first compartment))","code":""},{"path":"/reference/nonparametric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric distribution — nonparametric","text":"Distribution object simulator","code":""},{"path":"/reference/nonparametric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nonparametric distribution — nonparametric","text":"","code":"transitions <- list(\"S->I\"=nonparametric( c(0.1, 0.2, 0.5, 0.2) )) transitions <- denim_dsl({S->I=nonparametric( c(0.1, 0.2, 0.5, 0.2) )}) # you can also define a model parameter for the distribution transitions <- denim_dsl({S->I=nonparametric( dwelltime_dist )})"},{"path":"/reference/plot.denim.html","id":null,"dir":"Reference","previous_headings":"","what":"Overloaded plot function for denim object — plot.denim","title":"Overloaded plot function for denim object — plot.denim","text":"Overloaded plot function denim object","code":""},{"path":"/reference/plot.denim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Overloaded plot function for denim object — plot.denim","text":"","code":"# S3 method for denim plot(x, ..., color_palette = NULL)"},{"path":"/reference/plot.denim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Overloaded plot function for denim object — plot.denim","text":"x output denim::sim function ... additional parameter plot() function color_palette palette name colorspace package. can view available palettes colorspace::hcl_palettes(\"qualitative\", plot = TRUE).","code":""},{"path":"/reference/sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulator for deterministic discrete time model with memory — sim","title":"Simulator for deterministic discrete time model with memory — sim","text":"Simulation function call C++ simulator","code":""},{"path":"/reference/sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulator for deterministic discrete time model with memory — sim","text":"","code":"sim(   transitions,   initialValues,   parameters = NULL,   simulationDuration,   timeStep = 1,   errorTolerance = 0.001 )"},{"path":"/reference/sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulator for deterministic discrete time model with memory — sim","text":"transitions output function denim_dsl() list transitions follows format \"transition\" = distribution() initialValues vector contains initial values compartments defined transitions, follows format compartment_name = initial_value parameters vector contains values parameters compartments, usually parameters used mathexp() functions simulationDuration duration time simulate timeStep set output time interval. example, simulationDuration = 10 means 10 days timeStep = 0.1, output display results 0.1 daily interval errorTolerance set threshold cumulative distribution function can rounded 1. example, want cumulative probability 0.999 rounded 1, set errorTolerance = 0.001 (1 - 0.999 = 0.001). Default 0.001","code":""},{"path":"/reference/sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulator for deterministic discrete time model with memory — sim","text":"data.frame class denim can plotted plot() method","code":""},{"path":"/reference/sim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulator for deterministic discrete time model with memory — sim","text":"","code":"# model can be defined using denim DSL transitions <- denim_dsl({    S -> I = beta * S * I / N    I -> R = d_gamma(1/3, 2) })  # or as a list transitions <- list(    \"S -> I\" = \"beta * S * I / N\",    \"I -> R\" = d_gamma(1/3, 2) )  initialValues <- c(    S = 999,     I = 1,     R = 0 )  parameters <- c(    beta = 0.012,    N = 1000 )  simulationDuration <- 30 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep)"},{"path":"/reference/transprob.html","id":null,"dir":"Reference","previous_headings":"","what":"Transition probability — transprob","title":"Transition probability — transprob","text":"fixed percentage left compartment transit right compartment every time step","code":""},{"path":"/reference/transprob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transition probability — transprob","text":"","code":"transprob(x)"},{"path":"/reference/transprob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transition probability — transprob","text":"x float number 0 1","code":""},{"path":"/reference/transprob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transition probability — transprob","text":"Distribution object simulator","code":""},{"path":"/reference/transprob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transition probability — transprob","text":"","code":"transitions <- list(\"S->I\"=transprob(0.8))"},{"path":"/news/index.html","id":"denim-121","dir":"Changelog","previous_headings":"","what":"denim 1.2.1","title":"denim 1.2.1","text":"CRAN release: 2025-06-02 Minor runtime improvement Add option select color palette plot","code":""},{"path":"/news/index.html","id":"denim-120","dir":"Changelog","previous_headings":"","what":"denim 1.2.0","title":"denim 1.2.0","text":"CRAN release: 2025-05-30 Add denim DSL support Add error handlers","code":""},{"path":"/news/index.html","id":"denim-110","dir":"Changelog","previous_headings":"","what":"denim 1.1.0","title":"denim 1.1.0","text":"CRAN release: 2025-05-16 Fix multinomial vs competing risks transition Add distribute initial value feature","code":""},{"path":"/news/index.html","id":"denim-101","dir":"Changelog","previous_headings":"","what":"denim 1.0.1","title":"denim 1.0.1","text":"CRAN release: 2025-03-17 Remove deprecated syntax C++","code":""},{"path":"/news/index.html","id":"denim-100","dir":"Changelog","previous_headings":"","what":"denim 1.0.0","title":"denim 1.0.0","text":"CRAN release: 2024-06-05 Initial CRAN submission.","code":""}]
